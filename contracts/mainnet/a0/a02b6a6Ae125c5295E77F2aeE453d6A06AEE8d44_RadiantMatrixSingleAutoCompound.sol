//SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "./interfaces/beets/IBeetsVault.sol";
import "./Zapper.sol";

contract BeetsZapper is Zapper {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant BEETS_VAULT =
        0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce;
    IBeetsVault internal constant beetsVault = IBeetsVault(BEETS_VAULT);

    // Every LP has a poolId in Beets Vault contract
    mapping(address => bytes32) lpToPoolId;
    // Default token used to swap in Beets LP (default: 0th index)
    mapping(address => uint256) lpToTokenIndex;

    constructor() Zapper() {}

    function setLpToPoolId(address _lpToken, bytes32 _vaultPoolId)
        external
        onlyOwner
    {
        lpToPoolId[_lpToken] = _vaultPoolId;
    }

    function setLpToTokenIndex(address _lpToken, uint256 _defaultTokenIndex)
        external
        onlyOwner
    {
        lpToTokenIndex[_lpToken] = _defaultTokenIndex;
    }

    function _zapToLp(
        address _fromToken,
        address _toLpToken,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) internal virtual override returns (uint256 _lpAmountOut) {
        if (msg.value > 0) {
            // If you send FTM instead of WFTM these requirements must hold.
            require(_fromToken == WFTM, "invalid-from-token");
            require(_amountIn == msg.value, "invalid-amount-in");
            // Auto-wrap FTM to WFTM
            IWFTM(WFTM).deposit{value: msg.value}();
        } else {
            IERC20(_fromToken).safeTransferFrom(
                msg.sender,
                address(this),
                _amountIn
            );
        }

        bytes32 _lpPoolId = lpToPoolId[_toLpToken];
        (address[] memory _tokens, , ) = beetsVault.getPoolTokens(_lpPoolId);

        address _token = _tokens[lpToTokenIndex[_toLpToken]];
        uint256 _tokenOut = _swap(_fromToken, _token, _amountIn);

        IERC20(_token).safeApprove(BEETS_VAULT, 0);
        IERC20(_token).safeApprove(BEETS_VAULT, _tokenOut);

        uint256 _lpBalanceBefore = IERC20(_toLpToken).balanceOf(address(this));

        IVault.JoinPoolRequest memory _joinPoolRequest;
        _joinPoolRequest.assets = _tokens;
        _joinPoolRequest.maxAmountsIn = new uint256[](_tokens.length);
        _joinPoolRequest.maxAmountsIn[lpToTokenIndex[_toLpToken]] = _tokenOut;
        _joinPoolRequest.userData = abi.encode(
            1,
            _joinPoolRequest.maxAmountsIn,
            1
        );

        beetsVault.joinPool(
            _lpPoolId,
            address(this),
            address(this),
            _joinPoolRequest
        );

        _lpAmountOut =
            IERC20(_toLpToken).balanceOf(address(this)) -
            _lpBalanceBefore;
        require(_lpAmountOut >= _minLpAmountOut, "slippage-rekt-you");
    }

    function _unzapFromLp(
        address _fromLpToken,
        address _toToken,
        uint256 _amountLpIn,
        uint256 _minAmountOut
    ) internal virtual override returns (uint256 _amountOut) {
        bytes32 _lpPoolId = lpToPoolId[_fromLpToken];
        (address[] memory _tokens, , ) = beetsVault.getPoolTokens(_lpPoolId);

        IERC20(_fromLpToken).safeApprove(BEETS_VAULT, 0);
        IERC20(_fromLpToken).safeApprove(BEETS_VAULT, _amountLpIn);

        IVault.ExitPoolRequest memory _exitPoolRequest;
        _exitPoolRequest.assets = _tokens;
        _exitPoolRequest.minAmountsOut = new uint256[](_tokens.length);
        _exitPoolRequest.userData = abi.encode(1, _amountLpIn);
        _exitPoolRequest.toInternalBalance = false;

        beetsVault.exitPool(
            _lpPoolId,
            address(this),
            address(this),
            _exitPoolRequest
        );

        for (uint256 i; i < _tokens.length; i++) {
            uint256 _tokenBalance = IERC20(_tokens[i]).balanceOf(address(this));
            if (_tokenBalance > 0) _swap(_tokens[i], _toToken, _tokenBalance);
        }

        _amountOut = IERC20(_toToken).balanceOf(address(this));

        require(_amountOut >= _minAmountOut, "slippage-rekt-you");

        if (_toToken == WFTM) {
            IWFTM(WFTM).withdraw(_amountOut);

            (bool _success, ) = msg.sender.call{value: _amountOut}("");
            require(_success, "ftm-transfer-failed");
        } else {
            IERC20(_toToken).transfer(msg.sender, _amountOut);
        }
    }
}

// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity >=0.7.0 <0.9.0;

interface IBeetsVault {
    event AuthorizerChanged(address indexed newAuthorizer);
    event ExternalBalanceTransfer(
        address indexed token,
        address indexed sender,
        address recipient,
        uint256 amount
    );
    event FlashLoan(
        address indexed recipient,
        address indexed token,
        uint256 amount,
        uint256 feeAmount
    );
    event InternalBalanceChanged(
        address indexed user,
        address indexed token,
        int256 delta
    );
    event PausedStateChanged(bool paused);
    event PoolBalanceChanged(
        bytes32 indexed poolId,
        address indexed liquidityProvider,
        address[] tokens,
        int256[] deltas,
        uint256[] protocolFeeAmounts
    );
    event PoolBalanceManaged(
        bytes32 indexed poolId,
        address indexed assetManager,
        address indexed token,
        int256 cashDelta,
        int256 managedDelta
    );
    event PoolRegistered(
        bytes32 indexed poolId,
        address indexed poolAddress,
        uint8 specialization
    );
    event RelayerApprovalChanged(
        address indexed relayer,
        address indexed sender,
        bool approved
    );
    event Swap(
        bytes32 indexed poolId,
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 amountIn,
        uint256 amountOut
    );
    event TokensDeregistered(bytes32 indexed poolId, address[] tokens);
    event TokensRegistered(
        bytes32 indexed poolId,
        address[] tokens,
        address[] assetManagers
    );

    function WETH() external view returns (address);

    function batchSwap(
        uint8 kind,
        IVault.BatchSwapStep[] memory swaps,
        address[] memory assets,
        IVault.FundManagement memory funds,
        int256[] memory limits,
        uint256 deadline
    ) external payable returns (int256[] memory assetDeltas);

    function deregisterTokens(bytes32 poolId, address[] memory tokens) external;

    function exitPool(
        bytes32 poolId,
        address sender,
        address recipient,
        IVault.ExitPoolRequest memory request
    ) external;

    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;

    function getActionId(bytes4 selector) external view returns (bytes32);

    function getAuthorizer() external view returns (address);

    function getDomainSeparator() external view returns (bytes32);

    function getInternalBalance(address user, address[] memory tokens)
        external
        view
        returns (uint256[] memory balances);

    function getNextNonce(address user) external view returns (uint256);

    function getPausedState()
        external
        view
        returns (
            bool paused,
            uint256 pauseWindowEndTime,
            uint256 bufferPeriodEndTime
        );

    function getPool(bytes32 poolId) external view returns (address, uint8);

    function getPoolTokenInfo(bytes32 poolId, address token)
        external
        view
        returns (
            uint256 cash,
            uint256 managed,
            uint256 lastChangeBlock,
            address assetManager
        );

    function getPoolTokens(bytes32 poolId)
        external
        view
        returns (
            address[] memory tokens,
            uint256[] memory balances,
            uint256 lastChangeBlock
        );

    function getProtocolFeesCollector() external view returns (address);

    function hasApprovedRelayer(address user, address relayer)
        external
        view
        returns (bool);

    function joinPool(
        bytes32 poolId,
        address sender,
        address recipient,
        IVault.JoinPoolRequest memory request
    ) external payable;

    function managePoolBalance(IVault.PoolBalanceOp[] memory ops) external;

    function manageUserBalance(IVault.UserBalanceOp[] memory ops)
        external
        payable;

    function queryBatchSwap(
        uint8 kind,
        IVault.BatchSwapStep[] memory swaps,
        address[] memory assets,
        IVault.FundManagement memory funds
    ) external returns (int256[] memory);

    function registerPool(uint8 specialization) external returns (bytes32);

    function registerTokens(
        bytes32 poolId,
        address[] memory tokens,
        address[] memory assetManagers
    ) external;

    function setAuthorizer(address newAuthorizer) external;

    function setPaused(bool paused) external;

    function setRelayerApproval(
        address sender,
        address relayer,
        bool approved
    ) external;

    function swap(
        IVault.SingleSwap memory singleSwap,
        IVault.FundManagement memory funds,
        uint256 limit,
        uint256 deadline
    ) external payable returns (uint256 amountCalculated);

}

interface IVault {
    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address recipient;
        bool toInternalBalance;
    }

    struct JoinPoolRequest {
        address[] assets;
        uint256[] maxAmountsIn;
        bytes userData;
        bool fromInternalBalance;
    }

    struct ExitPoolRequest {
        address[] assets;
        uint256[] minAmountsOut;
        bytes userData;
        bool toInternalBalance;
    }

    struct PoolBalanceOp {
        uint8 kind;
        bytes32 poolId;
        address token;
        uint256 amount;
    }

    struct UserBalanceOp {
        uint8 kind;
        address asset;
        uint256 amount;
        address sender;
        address recipient;
    }

    struct SingleSwap {
        bytes32 poolId;
        uint8 kind;
        address assetIn;
        address assetOut;
        uint256 amount;
        bytes userData;
    }
}

// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:
/*
[{"inputs":[{"internalType":"contract IAuthorizer","name":"authorizer","type":"address"},{"internalType":"contract IWETH","name":"weth","type":"address"},{"internalType":"uint256","name":"pauseWindowDuration","type":"uint256"},{"internalType":"uint256","name":"bufferPeriodDuration","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"contract IAuthorizer","name":"newAuthorizer","type":"address"}],"name":"AuthorizerChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"contract IERC20","name":"token","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ExternalBalanceTransfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"contract IFlashLoanRecipient","name":"recipient","type":"address"},{"indexed":true,"internalType":"contract IERC20","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"feeAmount","type":"uint256"}],"name":"FlashLoan","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"contract IERC20","name":"token","type":"address"},{"indexed":false,"internalType":"int256","name":"delta","type":"int256"}],"name":"InternalBalanceChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bool","name":"paused","type":"bool"}],"name":"PausedStateChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"liquidityProvider","type":"address"},{"indexed":false,"internalType":"contract IERC20[]","name":"tokens","type":"address[]"},{"indexed":false,"internalType":"int256[]","name":"deltas","type":"int256[]"},{"indexed":false,"internalType":"uint256[]","name":"protocolFeeAmounts","type":"uint256[]"}],"name":"PoolBalanceChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"assetManager","type":"address"},{"indexed":true,"internalType":"contract IERC20","name":"token","type":"address"},{"indexed":false,"internalType":"int256","name":"cashDelta","type":"int256"},{"indexed":false,"internalType":"int256","name":"managedDelta","type":"int256"}],"name":"PoolBalanceManaged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"poolAddress","type":"address"},{"indexed":false,"internalType":"enum IVault.PoolSpecialization","name":"specialization","type":"uint8"}],"name":"PoolRegistered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"RelayerApprovalChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":true,"internalType":"contract IERC20","name":"tokenIn","type":"address"},{"indexed":true,"internalType":"contract IERC20","name":"tokenOut","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountIn","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountOut","type":"uint256"}],"name":"Swap","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":false,"internalType":"contract IERC20[]","name":"tokens","type":"address[]"}],"name":"TokensDeregistered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":false,"internalType":"contract IERC20[]","name":"tokens","type":"address[]"},{"indexed":false,"internalType":"address[]","name":"assetManagers","type":"address[]"}],"name":"TokensRegistered","type":"event"},{"inputs":[],"name":"WETH","outputs":[{"internalType":"contract IWETH","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"enum IVault.SwapKind","name":"kind","type":"uint8"},{"components":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"uint256","name":"assetInIndex","type":"uint256"},{"internalType":"uint256","name":"assetOutIndex","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes","name":"userData","type":"bytes"}],"internalType":"struct IVault.BatchSwapStep[]","name":"swaps","type":"tuple[]"},{"internalType":"contract IAsset[]","name":"assets","type":"address[]"},{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"bool","name":"fromInternalBalance","type":"bool"},{"internalType":"address payable","name":"recipient","type":"address"},{"internalType":"bool","name":"toInternalBalance","type":"bool"}],"internalType":"struct IVault.FundManagement","name":"funds","type":"tuple"},{"internalType":"int256[]","name":"limits","type":"int256[]"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"batchSwap","outputs":[{"internalType":"int256[]","name":"assetDeltas","type":"int256[]"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"contract IERC20[]","name":"tokens","type":"address[]"}],"name":"deregisterTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address payable","name":"recipient","type":"address"},{"components":[{"internalType":"contract IAsset[]","name":"assets","type":"address[]"},{"internalType":"uint256[]","name":"minAmountsOut","type":"uint256[]"},{"internalType":"bytes","name":"userData","type":"bytes"},{"internalType":"bool","name":"toInternalBalance","type":"bool"}],"internalType":"struct IVault.ExitPoolRequest","name":"request","type":"tuple"}],"name":"exitPool","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract IFlashLoanRecipient","name":"recipient","type":"address"},{"internalType":"contract IERC20[]","name":"tokens","type":"address[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"},{"internalType":"bytes","name":"userData","type":"bytes"}],"name":"flashLoan","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"selector","type":"bytes4"}],"name":"getActionId","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getAuthorizer","outputs":[{"internalType":"contract IAuthorizer","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getDomainSeparator","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"contract IERC20[]","name":"tokens","type":"address[]"}],"name":"getInternalBalance","outputs":[{"internalType":"uint256[]","name":"balances","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getNextNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPausedState","outputs":[{"internalType":"bool","name":"paused","type":"bool"},{"internalType":"uint256","name":"pauseWindowEndTime","type":"uint256"},{"internalType":"uint256","name":"bufferPeriodEndTime","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"}],"name":"getPool","outputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"enum IVault.PoolSpecialization","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"contract IERC20","name":"token","type":"address"}],"name":"getPoolTokenInfo","outputs":[{"internalType":"uint256","name":"cash","type":"uint256"},{"internalType":"uint256","name":"managed","type":"uint256"},{"internalType":"uint256","name":"lastChangeBlock","type":"uint256"},{"internalType":"address","name":"assetManager","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"}],"name":"getPoolTokens","outputs":[{"internalType":"contract IERC20[]","name":"tokens","type":"address[]"},{"internalType":"uint256[]","name":"balances","type":"uint256[]"},{"internalType":"uint256","name":"lastChangeBlock","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolFeesCollector","outputs":[{"internalType":"contract ProtocolFeesCollector","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"address","name":"relayer","type":"address"}],"name":"hasApprovedRelayer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"components":[{"internalType":"contract IAsset[]","name":"assets","type":"address[]"},{"internalType":"uint256[]","name":"maxAmountsIn","type":"uint256[]"},{"internalType":"bytes","name":"userData","type":"bytes"},{"internalType":"bool","name":"fromInternalBalance","type":"bool"}],"internalType":"struct IVault.JoinPoolRequest","name":"request","type":"tuple"}],"name":"joinPool","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"enum IVault.PoolBalanceOpKind","name":"kind","type":"uint8"},{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"contract IERC20","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"internalType":"struct IVault.PoolBalanceOp[]","name":"ops","type":"tuple[]"}],"name":"managePoolBalance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"enum IVault.UserBalanceOpKind","name":"kind","type":"uint8"},{"internalType":"contract IAsset","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address payable","name":"recipient","type":"address"}],"internalType":"struct IVault.UserBalanceOp[]","name":"ops","type":"tuple[]"}],"name":"manageUserBalance","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"enum IVault.SwapKind","name":"kind","type":"uint8"},{"components":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"uint256","name":"assetInIndex","type":"uint256"},{"internalType":"uint256","name":"assetOutIndex","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes","name":"userData","type":"bytes"}],"internalType":"struct IVault.BatchSwapStep[]","name":"swaps","type":"tuple[]"},{"internalType":"contract IAsset[]","name":"assets","type":"address[]"},{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"bool","name":"fromInternalBalance","type":"bool"},{"internalType":"address payable","name":"recipient","type":"address"},{"internalType":"bool","name":"toInternalBalance","type":"bool"}],"internalType":"struct IVault.FundManagement","name":"funds","type":"tuple"}],"name":"queryBatchSwap","outputs":[{"internalType":"int256[]","name":"","type":"int256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"enum IVault.PoolSpecialization","name":"specialization","type":"uint8"}],"name":"registerPool","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"contract IERC20[]","name":"tokens","type":"address[]"},{"internalType":"address[]","name":"assetManagers","type":"address[]"}],"name":"registerTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract IAuthorizer","name":"newAuthorizer","type":"address"}],"name":"setAuthorizer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"paused","type":"bool"}],"name":"setPaused","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"relayer","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setRelayerApproval","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"enum IVault.SwapKind","name":"kind","type":"uint8"},{"internalType":"contract IAsset","name":"assetIn","type":"address"},{"internalType":"contract IAsset","name":"assetOut","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes","name":"userData","type":"bytes"}],"internalType":"struct IVault.SingleSwap","name":"singleSwap","type":"tuple"},{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"bool","name":"fromInternalBalance","type":"bool"},{"internalType":"address payable","name":"recipient","type":"address"},{"internalType":"bool","name":"toInternalBalance","type":"bool"}],"internalType":"struct IVault.FundManagement","name":"funds","type":"tuple"},{"internalType":"uint256","name":"limit","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swap","outputs":[{"internalType":"uint256","name":"amountCalculated","type":"uint256"}],"stateMutability":"payable","type":"function"},{"stateMutability":"payable","type":"receive"}]
*/

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "./interfaces/IUniswapV2Pair.sol";
import "./interfaces/IWFTM.sol";
import "./interfaces/IMatrixVault.sol";
import "./strategies/MatrixSwapHelper.sol";

contract Zapper is MatrixSwapHelper, Ownable {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    event DefaultRouterChanged(
        address indexed _oldRouter,
        address indexed _newRouter
    );
    event CustomRouterSet(
        address indexed _lpToken,
        address indexed _customRouter
    );

    event ZapIn(
        address indexed _user,
        address indexed _vault,
        address indexed _want,
        uint256 _amountIn
    );

    event ZapOut(
        address indexed _user,
        address indexed _vault,
        address indexed _want,
        uint256 _amountOut
    );

    string public constant VERSION = "1.2";

    address public constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant SPOOKYSWAP_ROUTER =
        0xF491e7B69E4244ad4002BC14e878a34207E38c29;
    /// @dev Mapping of LP ERC20 -> Router
    /// In order to support a wider range of UniV2 forks
    mapping(address => address) public customRouter;

    /// @dev Mapping of Factory -> Router to retrieve
    /// the default router for LP token
    mapping(address => address) public factoryToRouter;

    /// @dev Default router for LP Tokens
    address public defaultRouter;
    

    /// @notice SPOOKYSWAP ROUTER AS DEFAULT FOR LP TOKENS AND SWAPS
    constructor() MatrixSwapHelper(SPOOKYSWAP_ROUTER) {
        /// Default router to put LPs in:
        _setDefaultRouter(SPOOKYSWAP_ROUTER);

        // Factory to Router
        // spookyswap
        factoryToRouter[0x152eE697f2E276fA89E96742e9bB9aB1F2E61bE3] = 0xF491e7B69E4244ad4002BC14e878a34207E38c29;

        // spiritswap
        factoryToRouter[0xEF45d134b73241eDa7703fa787148D9C9F4950b0] = 0x16327E3FbDaCA3bcF7E38F5Af2599D2DDc33aE52;

        // tombswap
        factoryToRouter[0xE236f6890F1824fa0a7ffc39b1597A5A6077Cfe9] = 0x6D0176C5ea1e44b08D3dd001b0784cE42F47a3A7;

        // hyperjump
        factoryToRouter[0x991152411A7B5A14A8CF0cDDE8439435328070dF] = 0x53c153a0df7E050BbEFbb70eE9632061f12795fB;

        // wigoswap
        factoryToRouter[0xC831A5cBfb4aC2Da5ed5B194385DFD9bF5bFcBa7] = 0x5023882f4D1EC10544FCB2066abE9C1645E95AA0;
    }

    receive() external payable {}

    /// @notice Get swap custom swap paths, if any
    /// @dev Otherwise reverts to default FROMTOKEN-WFTM-TOTOKEN behavior
    function getSwapPath(address _fromToken, address _toToken)
        public
        view
        override
        returns (SwapPath memory _swapPath)
    {
        bytes32 _swapKey = keccak256(abi.encodePacked(_fromToken, _toToken));
        if (swapPaths[_swapKey].path.length == 0) {
            if (_fromToken != WFTM && _toToken != WFTM) {
                address[] memory _path = new address[](3);
                _path[0] = _fromToken;
                _path[1] = WFTM;
                _path[2] = _toToken;
                _swapPath.path = _path;
            } else {
                address[] memory _path = new address[](2);
                _path[0] = _fromToken;
                _path[1] = _toToken;
                _swapPath.path = _path;
            }
            _swapPath.unirouter = unirouter;
        } else {
            return swapPaths[_swapKey];
        }
    }

    /// @dev Allows owner to set a custom swap path from a token to another
    /// @param _unirouter Can also set a custom unirouter for the swap, or address(0) for default router (spooky)
    function setSwapPath(
        address _fromToken,
        address _toToken,
        address _unirouter,
        address[] memory _path
    ) external onlyOwner {
        _setSwapPath(_fromToken, _toToken, _unirouter, _path);
    }

    function zapToLp(
        address _fromToken,
        address _toLpToken,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) external payable {
        uint256 _lpAmountOut = _zapToLp(
            _fromToken,
            _toLpToken,
            _amountIn,
            _minLpAmountOut
        );

        IERC20(_toLpToken).safeTransfer(msg.sender, _lpAmountOut);
    }

    function zapToMatrix(
        address _fromToken,
        address _matrixVault,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) external payable {
        IMatrixVault _vault = IMatrixVault(_matrixVault);
        address _toLpToken = _vault.want();

        uint256 _lpAmountOut = _zapToLp(
            _fromToken,
            _toLpToken,
            _amountIn,
            _minLpAmountOut
        );

        uint256 _vaultBalanceBefore = _vault.balanceOf(address(this));
        IERC20(_toLpToken).safeApprove(_matrixVault, _lpAmountOut);
        _vault.deposit(_lpAmountOut);
        uint256 _vaultAmountOut = _vault.balanceOf(address(this)) -
            _vaultBalanceBefore;
        require(_vaultAmountOut > 0, "deposit-in-vault-failed");
        _vault.transfer(msg.sender, _vaultAmountOut);

        emit ZapIn(msg.sender, address(_vault), _toLpToken, _lpAmountOut);
    }

    function unzapFromMatrix(
        address _matrixVault,
        address _toToken,
        uint256 _withdrawAmount,
        uint256 _minAmountOut
    ) external {
        IMatrixVault _vault = IMatrixVault(_matrixVault);
        address _fromLpToken = _vault.want();

        _vault.transferFrom(msg.sender, address(this), _withdrawAmount);
        _vault.withdraw(_withdrawAmount);

        uint256 _amountOut = _unzapFromLp(
            _fromLpToken,
            _toToken,
            IERC20(_fromLpToken).balanceOf(address(this)),
            _minAmountOut
        );

        emit ZapOut(msg.sender, address(_vault), _fromLpToken, _amountOut);
    }

    function unzapFromLp(
        address _fromLpToken,
        address _toToken,
        uint256 _amountLpIn,
        uint256 _minAmountOut
    ) external {
        IERC20(_fromLpToken).safeTransferFrom(msg.sender, address(this), _amountLpIn);
        _unzapFromLp(_fromLpToken, _toToken, _amountLpIn, _minAmountOut);
    }

    /// @notice In case tokens got stuck/mistakenly sent here
    function sweepERC20(address _token) external onlyOwner {
        IERC20(_token).safeTransfer(
            msg.sender,
            IERC20(_token).balanceOf(_token)
        );
    }

    function setDefaultRouter(address _newDefaultRouter) external onlyOwner {
        _setDefaultRouter(_newDefaultRouter);
    }

    function setCustomRouter(address _token, address _router)
        external
        onlyOwner
    {
        require(_token != address(0), "invalid-token-addr");
        require(_router != defaultRouter, "invalid-custom-router");
        emit CustomRouterSet(_token, _router);
        customRouter[_token] = _router;
    }

    function _setDefaultRouter(address _newDefaultRouter) internal {
        require(_newDefaultRouter != address(0), "invalid-default-router");
        emit DefaultRouterChanged(defaultRouter, _newDefaultRouter);
        defaultRouter = _newDefaultRouter;
    }

    function addRouter(address _factory, address _router) external onlyOwner {
        require(factoryToRouter[_factory] == address(0), "already-set");

        factoryToRouter[_factory] = _router;
    }

    /// @notice Get router for LPToken
    function _getRouter(address _lpToken) internal view virtual returns (address) {
        if (customRouter[_lpToken] != address(0)) return customRouter[_lpToken];
        
        address _factory = IUniswapV2Pair(_lpToken).factory();
        require(factoryToRouter[_factory] != address(0), "unsupported-router");

        return factoryToRouter[_factory];
    }

    function _zapToLp(
        address _fromToken,
        address _toLpToken,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) internal virtual returns (uint256 _lpAmountOut) {
        if (msg.value > 0) {
            // If you send FTM instead of WFTM these requirements must hold.
            require(_fromToken == WFTM, "invalid-from-token");
            require(_amountIn == msg.value, "invalid-amount-in");
            // Auto-wrap FTM to WFTM
            IWFTM(WFTM).deposit{value: msg.value}();
        } else {
            IERC20(_fromToken).safeTransferFrom(
                msg.sender,
                address(this),
                _amountIn
            );
        }

        address _router = _getRouter(_toLpToken);

        IERC20(_fromToken).safeApprove(_router, 0);
        IERC20(_fromToken).safeApprove(_router, _amountIn);

        address _token0 = IUniswapV2Pair(_toLpToken).token0();
        address _token1 = IUniswapV2Pair(_toLpToken).token1();

        address _defaultRouter = unirouter;
        unirouter = _router;
        // Uses lpToken' _router as the default router
        // You can override this by using setting a custom path
        // Using setSwapPath

        uint256 _token0Out = _swap(_fromToken, _token0, _amountIn / 2);
        uint256 _token1Out = _swap(
            _fromToken,
            _token1,
            _amountIn - (_amountIn / 2)
        );

        // Revert back to defaultRouter for swaps
        unirouter = _defaultRouter;

        IERC20(_token0).safeApprove(_router, 0);
        IERC20(_token1).safeApprove(_router, 0);
        IERC20(_token0).safeApprove(_router, _token0Out);
        IERC20(_token1).safeApprove(_router, _token1Out);

        uint256 _lpBalanceBefore = IERC20(_toLpToken).balanceOf(address(this));
        IUniswapV2Router02(_router).addLiquidity(
            _token0,
            _token1,
            _token0Out,
            _token1Out,
            0,
            0,
            address(this),
            block.timestamp
        );

        _lpAmountOut =
            IERC20(_toLpToken).balanceOf(address(this)) -
            _lpBalanceBefore;
        require(_lpAmountOut >= _minLpAmountOut, "slippage-rekt-you");
    }

    function _unzapFromLp(
        address _fromLpToken,
        address _toToken,
        uint256 _amountLpIn,
        uint256 _minAmountOut
    ) internal virtual returns (uint256 _amountOut) {
        address _router = _getRouter(_fromLpToken);

        address _token0 = IUniswapV2Pair(_fromLpToken).token0();
        address _token1 = IUniswapV2Pair(_fromLpToken).token1();

        IERC20(_fromLpToken).safeApprove(_router, 0);
        IERC20(_fromLpToken).safeApprove(_router, _amountLpIn);

        IUniswapV2Router02(_router).removeLiquidity(
            _token0,
            _token1,
            _amountLpIn,
            0,
            0,
            address(this),
            block.timestamp
        );

        address _defaultRouter = unirouter;
        unirouter = _router;
        // Uses lpToken' _router as the default router
        // You can override this by using setting a custom path
        // Using setSwapPath

        _swap(_token0, _toToken, IERC20(_token0).balanceOf(address(this)));
        _swap(_token1, _toToken, IERC20(_token1).balanceOf(address(this)));

        // Revert back to defaultRouter for swaps
        unirouter = _defaultRouter;

        _amountOut = IERC20(_toToken).balanceOf(address(this));

        require(_amountOut >= _minAmountOut, "slippage-rekt-you");

        if (_toToken == WFTM) {
            IWFTM(WFTM).withdraw(_amountOut);

            (bool _success, ) = msg.sender.call{value: _amountOut}("");
            require(_success, "ftm-transfer-failed");
        } else {
            IERC20(_toToken).transfer(msg.sender, _amountOut);
        }
    }

    function _checkPath(address[] memory _path) internal override {}

    function _checkRouter(address _router) internal override {}
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

pragma solidity >=0.6.2;

import './IUniswapV2Router01.sol';

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

interface IUniswapV2Pair {
  event Approval(address indexed owner, address indexed spender, uint value);
  event Transfer(address indexed from, address indexed to, uint value);

  function name() external pure returns (string memory);

  function symbol() external pure returns (string memory);

  function decimals() external pure returns (uint8);

  function totalSupply() external view returns (uint);

  function balanceOf(address owner) external view returns (uint);

  function allowance(address owner, address spender) external view returns (uint);

  function approve(address spender, uint value) external returns (bool);

  function transfer(address to, uint value) external returns (bool);

  function transferFrom(
    address from,
    address to,
    uint value
  ) external returns (bool);

  function DOMAIN_SEPARATOR() external view returns (bytes32);

  function PERMIT_TYPEHASH() external pure returns (bytes32);

  function nonces(address owner) external view returns (uint);

  function permit(
    address owner,
    address spender,
    uint value,
    uint deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external;

  event Mint(address indexed sender, uint amount0, uint amount1);
  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
  event Swap(
    address indexed sender,
    uint amount0In,
    uint amount1In,
    uint amount0Out,
    uint amount1Out,
    address indexed to
  );
  event Sync(uint112 reserve0, uint112 reserve1);

  function MINIMUM_LIQUIDITY() external pure returns (uint);

  function factory() external view returns (address);

  function token0() external view returns (address);

  function token1() external view returns (address);

  function getReserves()
    external
    view
    returns (
      uint112 reserve0,
      uint112 reserve1,
      uint32 blockTimestampLast
    );

  function price0CumulativeLast() external view returns (uint);

  function price1CumulativeLast() external view returns (uint);

  function kLast() external view returns (uint);

  function mint(address to) external returns (uint liquidity);

  function burn(address to) external returns (uint amount0, uint amount1);

  function swap(
    uint amount0Out,
    uint amount1Out,
    address to,
    bytes calldata data
  ) external;

  function skim(address to) external;

  function sync() external;

  function initialize(address, address) external;

  function stable() external returns (bool);
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IWFTM is IERC20 {
    function deposit() external payable;

    function withdraw(uint256) external;
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IMatrixVault is IERC20 {

    function want() external view returns (address);

    function deposit(uint256) external;

    function withdraw(uint256 _shares) external;

}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "../interfaces/IUniswapV2Pair.sol";
//import "hardhat/console.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";


/// @title Swap Helper to perform swaps and setting routes in matrix strategies
contract MatrixSwapHelper {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    address public unirouter;

    /// @dev Enumerable set of external tokens and routers
    /// strategy can interact with
    EnumerableSet.AddressSet internal whitelistedAddresses;

    struct SwapPath {
        address unirouter;
        address[] path;
    }

    mapping(bytes32 => SwapPath) internal swapPaths;

    constructor(address _uniRouter) {
        unirouter = _uniRouter;
    }

    function getWhitelistedAddresses()
        public
        virtual
        returns (address[] memory)
    {
        return whitelistedAddresses.values();
    }

    function getSwapPath(address _fromToken, address _toToken)
        public
        view
        virtual
        returns (SwapPath memory _swapPath)
    {
        bytes32 _swapKey = keccak256(abi.encodePacked(_fromToken, _toToken));
        require(swapPaths[_swapKey].unirouter != address(0), "path-not-found");
        return swapPaths[_swapKey];
    }

    function _setSwapPath(
        address _fromToken,
        address _toToken,
        address _unirouter,
        address[] memory _path
    ) internal virtual {
        require(_path[0] == _fromToken, "invalid-path");
        require(_path[_path.length - 1] == _toToken, "invalid-path");
        _checkPath(_path);

        bytes32 _swapKey = keccak256(abi.encodePacked(_fromToken, _toToken));
        address _router = _unirouter == address(0) ? unirouter : _unirouter;

        _checkRouter(_router);

        swapPaths[_swapKey] = SwapPath(_router, _path);
    }

    /// @dev Checks that tokens in path are whitelisted
    /// @notice Override this to skip checks
    function _checkPath(address[] memory _path) internal virtual {
        for (uint256 i; i < _path.length; i++)
        {
            //console.log(_path[i]);
            require(
                whitelistedAddresses.contains(_path[i]),
                "token-not-whitelisted"
            );
        }
    }

    /// @dev Checks that router for swap is whitelisted
    /// @notice Override this to skip checks
    function _checkRouter(address _router) internal virtual {
        require(
            whitelistedAddresses.contains(_router),
            "router-not-whitelisted"
        );
    }

    function _swap(
        address _fromToken,
        address _toToken,
        uint256 _amount
    ) internal virtual returns (uint256 _toTokenAmount) {
        if (_fromToken == _toToken) return _amount;
        SwapPath memory _swapPath = getSwapPath(_fromToken, _toToken);

        IERC20(_fromToken).safeApprove(_swapPath.unirouter, 0);
        IERC20(_fromToken).safeApprove(_swapPath.unirouter, type(uint256).max);
        
        // debugging: uncomment this block
        
        // console.log("_fromToken:", IERC20Metadata(_fromToken).symbol());
        // console.log("_toToken", IERC20Metadata(_toToken).symbol());
        // console.log("_path:");
        // for (uint i; i < _swapPath.path.length; i++) {
        //     console.log(_swapPath.path[i]);
        //     console.log(IERC20Metadata(_swapPath.path[i]).symbol());
        // }

        uint256 _toTokenBefore = IERC20(_toToken).balanceOf(address(this));
        IUniswapV2Router02(_swapPath.unirouter).swapExactTokensForTokens(
            _amount,
            0,
            _swapPath.path,
            address(this),
            block.timestamp
        );

        _toTokenAmount =
            IERC20(_toToken).balanceOf(address(this)) -
            _toTokenBefore;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

pragma solidity >=0.6.2;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)

pragma solidity ^0.8.0;

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
 * and `uint256` (`UintSet`) are supported.
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;
        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping(bytes32 => uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) {
            // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            if (lastIndex != toDeleteIndex) {
                bytes32 lastvalue = set._values[lastIndex];

                // Move the last value to the index where the value to delete is
                set._values[toDeleteIndex] = lastvalue;
                // Update the index for the moved value
                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex
            }

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        return set._values[index];
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function _values(Set storage set) private view returns (bytes32[] memory) {
        return set._values;
    }

    // Bytes32Set

    struct Bytes32Set {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _add(set._inner, value);
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _remove(set._inner, value);
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
        return _contains(set._inner, value);
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(Bytes32Set storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
        return _at(set._inner, index);
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
        return _values(set._inner);
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint160(uint256(_at(set._inner, index))));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(AddressSet storage set) internal view returns (address[] memory) {
        bytes32[] memory store = _values(set._inner);
        address[] memory result;

        assembly {
            result := store
        }

        return result;
    }

    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(UintSet storage set) internal view returns (uint256[] memory) {
        bytes32[] memory store = _values(set._inner);
        uint256[] memory result;

        assembly {
            result := store
        }

        return result;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "./interfaces/IUniswapV2Pair.sol";
import "./interfaces/IWETH.sol";
import "./interfaces/IMatrixVault.sol";
import "./strategies/MatrixSwapHelper.sol";

contract ZapperOptimism is MatrixSwapHelper, Ownable {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    event DefaultRouterChanged(
        address indexed _oldRouter,
        address indexed _newRouter
    );
    event CustomRouterSet(
        address indexed _lpToken,
        address indexed _customRouter
    );

    event ZapIn(
        address indexed _user,
        address indexed _vault,
        address indexed _want,
        uint256 _amountIn
    );

    event ZapOut(
        address indexed _user,
        address indexed _vault,
        address indexed _want,
        uint256 _amountOut
    );

    string public constant VERSION = "1.2";

    address public constant WETH = 0x4200000000000000000000000000000000000006;
    address internal constant ZIPSWAP_ROUTER =
        0xE6Df0BB08e5A97b40B21950a0A51b94c4DbA0Ff6;
    /// @dev Mapping of LP ERC20 -> Router
    /// In order to support a wider range of UniV2 forks
    mapping(address => address) public customRouter;

    /// @dev Mapping of Factory -> Router to retrieve
    /// the default router for LP token
    mapping(address => address) public factoryToRouter;

    /// @dev Default router for LP Tokens
    address public defaultRouter;

    /// @notice ZIPSWAP ROUTER AS DEFAULT FOR LP TOKENS AND SWAPS
    constructor() MatrixSwapHelper(ZIPSWAP_ROUTER) {
        /// Default router to put LPs in:
        _setDefaultRouter(ZIPSWAP_ROUTER);

        // Factory to Router
        // ZipSwap Optimism
        factoryToRouter[
            0x8BCeDD62DD46F1A76F8A1633d4f5B76e0CDa521E
        ] = 0xE6Df0BB08e5A97b40B21950a0A51b94c4DbA0Ff6;
    }

    receive() external payable {}

    /// @notice Get swap custom swap paths, if any
    /// @dev Otherwise reverts to default FROMTOKEN-WETH-TOTOKEN behavior
    function getSwapPath(address _fromToken, address _toToken)
        public
        view
        override
        returns (SwapPath memory _swapPath)
    {
        bytes32 _swapKey = keccak256(abi.encodePacked(_fromToken, _toToken));
        if (swapPaths[_swapKey].path.length == 0) {
            if (_fromToken != WETH && _toToken != WETH) {
                address[] memory _path = new address[](3);
                _path[0] = _fromToken;
                _path[1] = WETH;
                _path[2] = _toToken;
                _swapPath.path = _path;
            } else {
                address[] memory _path = new address[](2);
                _path[0] = _fromToken;
                _path[1] = _toToken;
                _swapPath.path = _path;
            }
            _swapPath.unirouter = unirouter;
        } else {
            return swapPaths[_swapKey];
        }
    }

    /// @dev Allows owner to set a custom swap path from a token to another
    /// @param _unirouter Can also set a custom unirouter for the swap, or address(0) for default router (spooky)
    function setSwapPath(
        address _fromToken,
        address _toToken,
        address _unirouter,
        address[] memory _path
    ) external onlyOwner {
        _setSwapPath(_fromToken, _toToken, _unirouter, _path);
    }

    function zapToLp(
        address _fromToken,
        address _toLpToken,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) external payable {
        uint256 _lpAmountOut = _zapToLp(
            _fromToken,
            _toLpToken,
            _amountIn,
            _minLpAmountOut
        );

        IERC20(_toLpToken).safeTransfer(msg.sender, _lpAmountOut);
    }

    function zapToMatrix(
        address _fromToken,
        address _matrixVault,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) external payable {
        IMatrixVault _vault = IMatrixVault(_matrixVault);
        address _toLpToken = _vault.want();

        uint256 _lpAmountOut = _zapToLp(
            _fromToken,
            _toLpToken,
            _amountIn,
            _minLpAmountOut
        );

        uint256 _vaultBalanceBefore = _vault.balanceOf(address(this));
        IERC20(_toLpToken).safeApprove(_matrixVault, _lpAmountOut);
        _vault.deposit(_lpAmountOut);
        uint256 _vaultAmountOut = _vault.balanceOf(address(this)) -
            _vaultBalanceBefore;
        require(_vaultAmountOut > 0, "deposit-in-vault-failed");
        _vault.transfer(msg.sender, _vaultAmountOut);

        emit ZapIn(msg.sender, address(_vault), _toLpToken, _lpAmountOut);
    }

    function unzapFromMatrix(
        address _matrixVault,
        address _toToken,
        uint256 _withdrawAmount,
        uint256 _minAmountOut
    ) external {
        IMatrixVault _vault = IMatrixVault(_matrixVault);
        address _fromLpToken = _vault.want();

        _vault.transferFrom(msg.sender, address(this), _withdrawAmount);
        _vault.withdraw(_withdrawAmount);

        uint256 _amountOut = _unzapFromLp(
            _fromLpToken,
            _toToken,
            IERC20(_fromLpToken).balanceOf(address(this)),
            _minAmountOut
        );

        emit ZapOut(msg.sender, address(_vault), _fromLpToken, _amountOut);
    }

    function unzapFromLp(
        address _fromLpToken,
        address _toToken,
        uint256 _amountLpIn,
        uint256 _minAmountOut
    ) external {
        IERC20(_fromLpToken).safeTransferFrom(
            msg.sender,
            address(this),
            _amountLpIn
        );
        _unzapFromLp(_fromLpToken, _toToken, _amountLpIn, _minAmountOut);
    }

    /// @notice In case tokens got stuck/mistakenly sent here
    function sweepERC20(address _token) external onlyOwner {
        IERC20(_token).safeTransfer(
            msg.sender,
            IERC20(_token).balanceOf(_token)
        );
    }

    function setDefaultRouter(address _newDefaultRouter) external onlyOwner {
        _setDefaultRouter(_newDefaultRouter);
    }

    function setCustomRouter(address _token, address _router)
        external
        onlyOwner
    {
        require(_token != address(0), "invalid-token-addr");
        require(_router != defaultRouter, "invalid-custom-router");
        emit CustomRouterSet(_token, _router);
        customRouter[_token] = _router;
    }

    function _setDefaultRouter(address _newDefaultRouter) internal {
        require(_newDefaultRouter != address(0), "invalid-default-router");
        emit DefaultRouterChanged(defaultRouter, _newDefaultRouter);
        defaultRouter = _newDefaultRouter;
    }

    function addRouter(address _factory, address _router) external onlyOwner {
        require(factoryToRouter[_factory] == address(0), "already-set");

        factoryToRouter[_factory] = _router;
    }

    /// @notice Get router for LPToken
    function _getRouter(address _lpToken)
        internal
        view
        virtual
        returns (address)
    {
        if (customRouter[_lpToken] != address(0)) return customRouter[_lpToken];

        address _factory = IUniswapV2Pair(_lpToken).factory();
        require(factoryToRouter[_factory] != address(0), "unsupported-router");

        return factoryToRouter[_factory];
    }

    function _zapToLp(
        address _fromToken,
        address _toLpToken,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) internal virtual returns (uint256 _lpAmountOut) {
        if (msg.value > 0) {
            // If you send FTM instead of WETH these requirements must hold.
            require(_fromToken == WETH, "invalid-from-token");
            require(_amountIn == msg.value, "invalid-amount-in");
            // Auto-wrap FTM to WETH
            IWETH(WETH).deposit{value: msg.value}();
        } else {
            IERC20(_fromToken).safeTransferFrom(
                msg.sender,
                address(this),
                _amountIn
            );
        }

        address _router = _getRouter(_toLpToken);

        IERC20(_fromToken).safeApprove(_router, 0);
        IERC20(_fromToken).safeApprove(_router, _amountIn);

        address _token0 = IUniswapV2Pair(_toLpToken).token0();
        address _token1 = IUniswapV2Pair(_toLpToken).token1();

        address _defaultRouter = unirouter;
        unirouter = _router;
        // Uses lpToken' _router as the default router
        // You can override this by using setting a custom path
        // Using setSwapPath

        uint256 _token0Out = _swap(_fromToken, _token0, _amountIn / 2);
        uint256 _token1Out = _swap(
            _fromToken,
            _token1,
            _amountIn - (_amountIn / 2)
        );

        // Revert back to defaultRouter for swaps
        unirouter = _defaultRouter;

        IERC20(_token0).safeApprove(_router, 0);
        IERC20(_token1).safeApprove(_router, 0);
        IERC20(_token0).safeApprove(_router, _token0Out);
        IERC20(_token1).safeApprove(_router, _token1Out);

        uint256 _lpBalanceBefore = IERC20(_toLpToken).balanceOf(address(this));

        _addLiquidity(_router, _token0, _token1, _token0Out, _token1Out, false);

        _lpAmountOut =
            IERC20(_toLpToken).balanceOf(address(this)) -
            _lpBalanceBefore;
        require(_lpAmountOut >= _minLpAmountOut, "slippage-rekt-you");
    }

    function _addLiquidity(
        address _router,
        address _token0,
        address _token1,
        uint256 _token0Out,
        uint256 _token1Out,
        bool _stable
    ) internal virtual {
        IUniswapV2Router02(_router).addLiquidity(
            _token0,
            _token1,
            _token0Out,
            _token1Out,
            0,
            0,
            address(this),
            block.timestamp
        );
    }

    function _removeLiquidity(
        address _router,
        address _token0,
        address _token1,
        uint256 _amountLpIn,
        bool _stable
    ) internal virtual {
        IUniswapV2Router02(_router).removeLiquidity(
            _token0,
            _token1,
            _amountLpIn,
            0,
            0,
            address(this),
            block.timestamp
        );
    }

    function _unzapFromLp(
        address _fromLpToken,
        address _toToken,
        uint256 _amountLpIn,
        uint256 _minAmountOut
    ) internal virtual returns (uint256 _amountOut) {
        address _router = _getRouter(_fromLpToken);

        address _token0 = IUniswapV2Pair(_fromLpToken).token0();
        address _token1 = IUniswapV2Pair(_fromLpToken).token1();

        IERC20(_fromLpToken).safeApprove(_router, 0);
        IERC20(_fromLpToken).safeApprove(_router, _amountLpIn);

        _removeLiquidity(_router, _token0, _token1, _amountLpIn, false);

        address _defaultRouter = unirouter;
        unirouter = _router;
        // Uses lpToken' _router as the default router
        // You can override this by using setting a custom path
        // Using setSwapPath

        _swap(_token0, _toToken, IERC20(_token0).balanceOf(address(this)));
        _swap(_token1, _toToken, IERC20(_token1).balanceOf(address(this)));

        // Revert back to defaultRouter for swaps
        unirouter = _defaultRouter;

        _amountOut = IERC20(_toToken).balanceOf(address(this));

        require(_amountOut >= _minAmountOut, "slippage-rekt-you");

        if (_toToken == WETH) {
            IWETH(WETH).withdraw(_amountOut);

            (bool _success, ) = msg.sender.call{value: _amountOut}("");
            require(_success, "eth-transfer-failed");
        } else {
            IERC20(_toToken).transfer(msg.sender, _amountOut);
        }
    }

    function _checkPath(address[] memory _path) internal override {}

    function _checkRouter(address _router) internal override {}
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IWETH is IERC20 {
    function deposit() external payable;

    function withdraw(uint256) external;
}

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "./ZapperOptimism.sol";
import "./interfaces/velodrome/IVelodromeRouter.sol";
//import "hardhat/console.sol";

contract ZapperVelodrome is ZapperOptimism {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    /// @notice ZIPSWAP ROUTER AS DEFAULT FOR LP TOKENS AND SWAPS

    address internal constant VELODROME_ROUTER =
        0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9;

    constructor() {
        _setDefaultRouter(VELODROME_ROUTER);

        address[] memory _path = new address[](3);
        _path[0] = 0x4200000000000000000000000000000000000006;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0xdFA46478F9e5EA86d57387849598dbFB2e964b02;
        _setSwapPath(
            0x4200000000000000000000000000000000000006,
            0xdFA46478F9e5EA86d57387849598dbFB2e964b02,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0x4200000000000000000000000000000000000006;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x217D47011b23BB961eB6D93cA9945B7501a5BB11;
        _setSwapPath(
            0x4200000000000000000000000000000000000006,
            0x217D47011b23BB961eB6D93cA9945B7501a5BB11,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0x4200000000000000000000000000000000000006;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0xc40F949F8a4e094D1b49a23ea9241D289B7b2819;
        _setSwapPath(
            0x4200000000000000000000000000000000000006,
            0xc40F949F8a4e094D1b49a23ea9241D289B7b2819,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0x4200000000000000000000000000000000000006;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0xCB8FA9a76b8e203D8C3797bF438d8FB81Ea3326A;
        _setSwapPath(
            0x4200000000000000000000000000000000000006,
            0xCB8FA9a76b8e203D8C3797bF438d8FB81Ea3326A,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0x4200000000000000000000000000000000000006;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x2E3D870790dC77A83DD1d18184Acc7439A53f475;
        _setSwapPath(
            0x4200000000000000000000000000000000000006,
            0x2E3D870790dC77A83DD1d18184Acc7439A53f475,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0x4200000000000000000000000000000000000006;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x10010078a54396F62c96dF8532dc2B4847d47ED3;
        _setSwapPath(
            0x4200000000000000000000000000000000000006,
            0x10010078a54396F62c96dF8532dc2B4847d47ED3,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0xdFA46478F9e5EA86d57387849598dbFB2e964b02;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x4200000000000000000000000000000000000006;
        _setSwapPath(
            0xdFA46478F9e5EA86d57387849598dbFB2e964b02,
            0x4200000000000000000000000000000000000006,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0x217D47011b23BB961eB6D93cA9945B7501a5BB11;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x4200000000000000000000000000000000000006;
        _setSwapPath(
            0x217D47011b23BB961eB6D93cA9945B7501a5BB11,
            0x4200000000000000000000000000000000000006,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0xc40F949F8a4e094D1b49a23ea9241D289B7b2819;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x4200000000000000000000000000000000000006;
        _setSwapPath(
            0xc40F949F8a4e094D1b49a23ea9241D289B7b2819,
            0x4200000000000000000000000000000000000006,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0xCB8FA9a76b8e203D8C3797bF438d8FB81Ea3326A;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x4200000000000000000000000000000000000006;
        _setSwapPath(
            0xCB8FA9a76b8e203D8C3797bF438d8FB81Ea3326A,
            0x4200000000000000000000000000000000000006,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0x2E3D870790dC77A83DD1d18184Acc7439A53f475;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x4200000000000000000000000000000000000006;
        _setSwapPath(
            0x2E3D870790dC77A83DD1d18184Acc7439A53f475,
            0x4200000000000000000000000000000000000006,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0x10010078a54396F62c96dF8532dc2B4847d47ED3;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x4200000000000000000000000000000000000006;
        _setSwapPath(
            0x10010078a54396F62c96dF8532dc2B4847d47ED3,
            0x4200000000000000000000000000000000000006,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0x4200000000000000000000000000000000000006;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x4200000000000000000000000000000000000042;
        _setSwapPath(
            0x4200000000000000000000000000000000000006,
            0x4200000000000000000000000000000000000042,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0x4200000000000000000000000000000000000042;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x4200000000000000000000000000000000000006;
        _setSwapPath(
            0x4200000000000000000000000000000000000042,
            0x4200000000000000000000000000000000000006,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );

        _path[0] = 0x4200000000000000000000000000000000000006;
        _path[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _path[2] = 0x3c8B650257cFb5f272f799F5e2b4e65093a11a05;
        _setSwapPath(
            0x4200000000000000000000000000000000000006,
            0x3c8B650257cFb5f272f799F5e2b4e65093a11a05,
            0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9,
            _path
        );
    }

    function _getRouter(
        address /* _lpToken */
    ) internal view override returns (address) {
        return VELODROME_ROUTER;
    }

    function _swap(
        address _fromToken,
        address _toToken,
        uint256 _amount
    ) internal override returns (uint256 _toTokenAmount) {
        if (_fromToken == _toToken) return _amount;
        SwapPath memory _swapPath = getSwapPath(_fromToken, _toToken);

        route[] memory _routes = new route[](_swapPath.path.length - 1);

        uint256 _lastAmountBack = _amount;
        for (uint256 i; i < _swapPath.path.length - 1; i++) {
            (uint256 _amountBack, bool _stable) = IVelodromeRouter(
                _swapPath.unirouter
            ).getAmountOut(
                    _lastAmountBack,
                    _swapPath.path[i],
                    _swapPath.path[i + 1]
                );
            _lastAmountBack = _amountBack;
            _routes[i] = route({
                from: _swapPath.path[i],
                to: _swapPath.path[i + 1],
                stable: _stable
            });
        }

        IERC20(_fromToken).safeApprove(_swapPath.unirouter, 0);
        IERC20(_fromToken).safeApprove(_swapPath.unirouter, type(uint256).max);

        // debugging: uncomment this block
        // console.log("_inputAmount", _amount);
        // console.log("_fromToken:", IERC20Metadata(_fromToken).symbol());
        // console.log("_toToken:", IERC20Metadata(_toToken).symbol());
        // console.log("_path:");
        // for (uint256 i; i < _swapPath.path.length - 1; i++) {
        //     console.log(IERC20Metadata(_swapPath.path[i]).symbol());
        //     console.log("isStable:", _routes[i].stable);
        // }
        // console.log(
        //     IERC20Metadata(_swapPath.path[_swapPath.path.length - 1]).symbol()
        // );

        uint256 _toTokenBefore = IERC20(_toToken).balanceOf(address(this));
        IVelodromeRouter(_swapPath.unirouter).swapExactTokensForTokens(
            _amount,
            0,
            _routes,
            address(this),
            block.timestamp
        );

        _toTokenAmount =
            IERC20(_toToken).balanceOf(address(this)) -
            _toTokenBefore;

        //console.log("_toTokenAmount:", _toTokenAmount);
    }

    function _addLiquidity(
        address _router,
        address _token0,
        address _token1,
        uint256 _token0Out,
        uint256 _token1Out,
        bool _stable
    ) internal override {
        IVelodromeRouter(_router).addLiquidity(
            _token0,
            _token1,
            _stable,
            _token0Out,
            _token1Out,
            0,
            0,
            address(this),
            block.timestamp
        );
    }

    function _removeLiquidity(
        address _router,
        address _token0,
        address _token1,
        uint256 _amountLpIn,
        bool _stable
    ) internal override {
        IVelodromeRouter(_router).removeLiquidity(
            _token0,
            _token1,
            _stable,
            _amountLpIn,
            0,
            0,
            address(this),
            block.timestamp
        );
    }

    function _unzapFromLp(
        address _fromLpToken,
        address _toToken,
        uint256 _amountLpIn,
        uint256 _minAmountOut
    ) internal override returns (uint256 _amountOut) {
        address _router = _getRouter(_fromLpToken);

        bool _isStable = IUniswapV2Pair(_fromLpToken).stable();
        address _token0 = IUniswapV2Pair(_fromLpToken).token0();
        address _token1 = IUniswapV2Pair(_fromLpToken).token1();

        IERC20(_fromLpToken).safeApprove(_router, 0);
        IERC20(_fromLpToken).safeApprove(_router, _amountLpIn);

        _removeLiquidity(_router, _token0, _token1, _amountLpIn, _isStable);

        address _defaultRouter = unirouter;
        unirouter = _router;
        // Uses lpToken' _router as the default router
        // You can override this by using setting a custom path
        // Using setSwapPath

        _swap(_token0, _toToken, IERC20(_token0).balanceOf(address(this)));
        _swap(_token1, _toToken, IERC20(_token1).balanceOf(address(this)));

        // Revert back to defaultRouter for swaps
        unirouter = _defaultRouter;

        _amountOut = IERC20(_toToken).balanceOf(address(this));

        require(_amountOut >= _minAmountOut, "slippage-rekt-you");

        if (_toToken == WETH) {
            IWETH(WETH).withdraw(_amountOut);

            (bool _success, ) = msg.sender.call{value: _amountOut}("");
            require(_success, "eth-transfer-failed");
        } else {
            IERC20(_toToken).transfer(msg.sender, _amountOut);
        }
    }

    function _getRatio(address _lpToken) internal view returns (uint256) {
        address _token0 = IUniswapV2Pair(_lpToken).token0();
        address _token1 = IUniswapV2Pair(_lpToken).token1();

        (uint256 opLp0, uint256 opLp1, ) = IUniswapV2Pair(_lpToken)
            .getReserves();
        uint256 lp0Amt = (opLp0 * (10**18)) /
            (10**IERC20Metadata(_token0).decimals());
        uint256 lp1Amt = (opLp1 * (10**18)) /
            (10**IERC20Metadata(_token1).decimals());
        uint256 totalSupply = lp0Amt + (lp1Amt);
        return (lp0Amt * (10**18)) / (totalSupply);
    }

    function _zapToLp(
        address _fromToken,
        address _toLpToken,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) internal override returns (uint256 _lpAmountOut) {
        if (msg.value > 0) {
            // If you send FTM instead of WETH these requirements must hold.
            require(_fromToken == WETH, "invalid-from-token");
            require(_amountIn == msg.value, "invalid-amount-in");
            // Auto-wrap FTM to WETH
            IWETH(WETH).deposit{value: msg.value}();
        } else {
            IERC20(_fromToken).safeTransferFrom(
                msg.sender,
                address(this),
                _amountIn
            );
        }

        address _router = _getRouter(_toLpToken);

        IERC20(_fromToken).safeApprove(_router, 0);
        IERC20(_fromToken).safeApprove(_router, _amountIn);

        bool _isStable = IUniswapV2Pair(_toLpToken).stable();
        address _token0 = IUniswapV2Pair(_toLpToken).token0();
        address _token1 = IUniswapV2Pair(_toLpToken).token1();

        address _defaultRouter = unirouter;
        unirouter = _router;
        // Uses lpToken' _router as the default router
        // You can override this by using setting a custom path
        // Using setSwapPath

        uint256 _token0Out;
        uint256 _token1Out;

        if (!_isStable) {
            _token0Out = _swap(_fromToken, _token0, _amountIn / 2);
            _token1Out = _swap(
                _fromToken,
                _token1,
                _amountIn - (_amountIn / 2)
            );
        } else {
            uint256 _amount0In = (_amountIn * _getRatio(_toLpToken)) / 10**18;
            uint256 _amount1In = _amountIn - _amount0In;
            _token0Out = _swap(_fromToken, _token0, _amount0In);
            _token1Out = _swap(_fromToken, _token1, _amount1In);
        }

        // Revert back to defaultRouter for swaps
        unirouter = _defaultRouter;

        IERC20(_token0).safeApprove(_router, 0);
        IERC20(_token1).safeApprove(_router, 0);
        IERC20(_token0).safeApprove(_router, _token0Out);
        IERC20(_token1).safeApprove(_router, _token1Out);

        uint256 _lpBalanceBefore = IERC20(_toLpToken).balanceOf(address(this));

        _addLiquidity(
            _router,
            _token0,
            _token1,
            _token0Out,
            _token1Out,
            _isStable
        );

        _lpAmountOut =
            IERC20(_toLpToken).balanceOf(address(this)) -
            _lpBalanceBefore;
        require(_lpAmountOut >= _minLpAmountOut, "slippage-rekt-you");
    }
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

struct route {
    address from;
    address to;
    bool stable;
}

interface IVelodromeRouter {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        route[] calldata routes,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function addLiquidity(
        address tokenA,
        address tokenB,
        bool stable,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        bool stable,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);

    function quoteAddLiquidity(
        address tokenA,
        address tokenB,
        bool stable,
        uint amountADesired,
        uint amountBDesired
    ) external view returns (uint amountA, uint amountB, uint liquidity);

    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable);

}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixLpAutoCompound.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "../../interfaces/IGauge.sol";
import "../../interfaces/velodrome/IVelodromeRouter.sol";

//import "hardhat/console.sol";

/// @title Velodrome Matrix Lp AutoCompound Strategy
contract VeloMatrixLpAutoCompound is MatrixLpAutoCompound {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    bool public isStable;

    address internal constant sUSD = 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9;
    address internal constant MAI = 0xdFA46478F9e5EA86d57387849598dbFB2e964b02;
    address internal constant OP = 0x4200000000000000000000000000000000000042;
    address internal constant LYRA = 0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb;
    address internal constant THALES =
        0x217D47011b23BB961eB6D93cA9945B7501a5BB11;
    address internal constant LUSD = 0xc40F949F8a4e094D1b49a23ea9241D289B7b2819;
    address internal constant alUSD =
        0xCB8FA9a76b8e203D8C3797bF438d8FB81Ea3326A;
    address internal constant FRAX = 0x2E3D870790dC77A83DD1d18184Acc7439A53f475;
    address internal constant sETH = 0xE405de8F52ba7559f9df3C368500B6E6ae6Cee49;
    address internal constant HND = 0x10010078a54396F62c96dF8532dc2B4847d47ED3;
    address internal constant L2DAO = 0xd52f94DF742a6F4B4C8b033369fE13A41782Bf44;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        bool _isStable,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {
        isStable = _isStable;
    }

    function _initialize(address _masterchef, address _output, uint256 _poolId) internal override {
        wrapped = 0x4200000000000000000000000000000000000006;
        treasury = 0xEaD9f532C72CF35dAb18A42223eE7A1B19bC5aBF;
        USDC = address(0x7F5c764cBc14f9669B88837ca1490cCa17c31607);
        partner = address(0xb074ec6c37659525EEf2Fb44478077901F878012);
        treasuryFee = 4500;
        partnerFee = 4500;
        super._initialize(_masterchef, _output, _poolId);
    }

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(USDC);
        whitelistedAddresses.add(L2DAO);
        whitelistedAddresses.add(OP);
        whitelistedAddresses.add(sUSD);
        whitelistedAddresses.add(MAI);
        whitelistedAddresses.add(USDC);
        whitelistedAddresses.add(LYRA);
        whitelistedAddresses.add(THALES);
        whitelistedAddresses.add(LUSD);
        whitelistedAddresses.add(alUSD);
        whitelistedAddresses.add(FRAX);
        whitelistedAddresses.add(sETH);
        whitelistedAddresses.add(HND);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();

        // VELO -> USDC
        address[] memory _VELOsUSD = new address[](4);
        _VELOsUSD[0] = output;
        _VELOsUSD[1] = wrapped;
        _VELOsUSD[2] = USDC;
        _VELOsUSD[3] = sUSD;
        _setSwapPath(output, sUSD, unirouter, _VELOsUSD);

        // VELO -> WETH
        address[] memory _VELOWETH = new address[](3);
        _VELOWETH[0] = output;
        _VELOWETH[1] = USDC;
        _VELOWETH[2] = wrapped;
        _setSwapPath(output, wrapped, unirouter, _VELOWETH);

        // VELO -> MAI
        address[] memory _VELOMAI = new address[](3);
        _VELOMAI[0] = 0x3c8B650257cFb5f272f799F5e2b4e65093a11a05;
        _VELOMAI[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _VELOMAI[2] = 0xdFA46478F9e5EA86d57387849598dbFB2e964b02;
        _setSwapPath(output, MAI, unirouter, _VELOMAI);

        // VELO -> OP
        address[] memory _VELOOP = new address[](3);
        _VELOOP[0] = output;
        _VELOOP[1] = USDC;
        _VELOOP[2] = OP;
        _setSwapPath(output, OP, unirouter, _VELOOP);

        // VELO -> L2DAO
        address[] memory _VELOL2DAO = new address[](4);
        _VELOL2DAO[0] = output;
        _VELOL2DAO[1] = USDC;
        _VELOL2DAO[2] = OP;
        _VELOL2DAO[3] = L2DAO;
        _setSwapPath(output, L2DAO, unirouter, _VELOL2DAO);

        // VELO -> LYRA
        address[] memory _VELOLYRA = new address[](3);
        _VELOLYRA[0] = output;
        _VELOLYRA[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _VELOLYRA[2] = 0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb;
        _setSwapPath(output, LYRA, unirouter, _VELOLYRA);

        // VELO -> THALES
        address[] memory _VELOTHALES = new address[](3);
        _VELOTHALES[0] = 0x3c8B650257cFb5f272f799F5e2b4e65093a11a05;
        _VELOTHALES[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _VELOTHALES[2] = 0x217D47011b23BB961eB6D93cA9945B7501a5BB11;
        _setSwapPath(output, THALES, unirouter, _VELOTHALES);

        // VELO -> LUSD
        address[] memory _VELOLUSD = new address[](3);
        _VELOLUSD[0] = 0x3c8B650257cFb5f272f799F5e2b4e65093a11a05;
        _VELOLUSD[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _VELOLUSD[2] = 0xc40F949F8a4e094D1b49a23ea9241D289B7b2819;
        _setSwapPath(output, LUSD, unirouter, _VELOLUSD);

        // VELO -> alUSD
        address[] memory _VELOalUSD = new address[](3);
        _VELOalUSD[0] = 0x3c8B650257cFb5f272f799F5e2b4e65093a11a05;
        _VELOalUSD[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _VELOalUSD[2] = 0xCB8FA9a76b8e203D8C3797bF438d8FB81Ea3326A;
        _setSwapPath(output, alUSD, unirouter, _VELOalUSD);

        // VELO -> FRAX
        address[] memory _VELOFRAX = new address[](3);
        _VELOFRAX[0] = 0x3c8B650257cFb5f272f799F5e2b4e65093a11a05;
        _VELOFRAX[1] = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
        _VELOFRAX[2] = 0x2E3D870790dC77A83DD1d18184Acc7439A53f475;
        _setSwapPath(output, FRAX, unirouter, _VELOFRAX);

        // VELO -> sETH
        address[] memory _VELOsETH = new address[](4);
        _VELOsETH[0] = output;
        _VELOsETH[1] = USDC;
        _VELOsETH[2] = wrapped;
        _VELOsETH[3] = sETH;
        _setSwapPath(output, sETH, unirouter, _VELOsETH);

        // VELO -> HND
        address[] memory _VELOHND = new address[](3);
        _VELOHND[0] = output;
        _VELOHND[1] = USDC;
        _VELOHND[2] = HND;
        _setSwapPath(output, HND, unirouter, _VELOHND);
    }

    function totalValue() public view override returns (uint256) {
        uint256 _totalStaked = IGauge(masterchef).balanceOf(address(this));
        return IERC20(want).balanceOf(address(this)) + _totalStaked;
    }

    function _beforeWithdraw(uint256 _amount) internal override {
        IGauge(masterchef).withdraw(_amount);
    }

    function _beforeHarvest() internal override {
        address[] memory _tokens = new address[](1);
        _tokens[0] = output;
        IGauge(masterchef).getReward(address(this), _tokens);
    }

    function _deposit() internal virtual override {
        uint256 _wantBalance = IERC20(want).balanceOf(address(this));
        if (_wantBalance > 0) IGauge(masterchef).deposit(_wantBalance, poolId);
    }

    function _beforePanic() internal virtual override {
        IGauge(masterchef).withdrawAll();
    }

    function _getRatio(address _lpToken) internal view returns (uint256) {
        address _token0 = IUniswapV2Pair(_lpToken).token0();
        address _token1 = IUniswapV2Pair(_lpToken).token1();

        (uint256 opLp0, uint256 opLp1, ) = IUniswapV2Pair(_lpToken)
            .getReserves();
        uint256 lp0Amt = (opLp0 * (10**18)) /
            (10**IERC20Metadata(_token0).decimals());
        uint256 lp1Amt = (opLp1 * (10**18)) /
            (10**IERC20Metadata(_token1).decimals());
        uint256 totalSupply = lp0Amt + (lp1Amt);
        return (lp0Amt * (10**18)) / (totalSupply);
    }

    function _swap(
        address _fromToken,
        address _toToken,
        uint256 _amount
    ) internal override returns (uint256 _toTokenAmount) {
        if (_fromToken == _toToken) return _amount;
        SwapPath memory _swapPath = getSwapPath(_fromToken, _toToken);

        route[] memory _routes = new route[](_swapPath.path.length - 1);

        uint256 _lastAmountBack = _amount;
        for (uint256 i; i < _swapPath.path.length - 1; i++) {
            (uint256 _amountBack, bool _stable) = IVelodromeRouter(
                _swapPath.unirouter
            ).getAmountOut(
                    _lastAmountBack,
                    _swapPath.path[i],
                    _swapPath.path[i + 1]
                );
            _lastAmountBack = _amountBack;
            _routes[i] = route({
                from: _swapPath.path[i],
                to: _swapPath.path[i + 1],
                stable: _stable
            });
        }

        IERC20(_fromToken).safeApprove(_swapPath.unirouter, 0);
        IERC20(_fromToken).safeApprove(_swapPath.unirouter, type(uint256).max);

        // debugging: uncomment this block
        // console.log("++++++++++");
        // console.log("_fromToken:", IERC20Metadata(_fromToken).symbol());
        // console.log("_fromAddr:", _fromToken);
        // console.log("_toToken:", IERC20Metadata(_toToken).symbol());
        // console.log("_toAddr:", _toToken);
        // console.log("_amount:", _amount);
        // console.log("_path:");
        // for (uint256 i; i < _swapPath.path.length; i++) {
        //     console.log(
        //         IERC20Metadata(_swapPath.path[i]).symbol(),
        //         _swapPath.path[i]
        //     );
        //     console.log("-----");
        // }
        // console.log("++++++++++");
        // console.log("");

        uint256 _toTokenBefore = IERC20(_toToken).balanceOf(address(this));
        IVelodromeRouter(_swapPath.unirouter).swapExactTokensForTokens(
            _amount,
            0,
            _routes,
            address(this),
            block.timestamp
        );

        _toTokenAmount =
            IERC20(_toToken).balanceOf(address(this)) -
            _toTokenBefore;
    }

    function _addLiquidity(uint256 _outputAmount)
        internal
        override
        returns (uint256 _wantHarvested)
    {
        uint256 _wantBalanceBefore = IERC20(want).balanceOf(address(this));
        uint256 _lpToken0BalanceBefore = IERC20(lpToken0).balanceOf(
            address(this)
        );
        uint256 _lpToken1BalanceBefore = IERC20(lpToken1).balanceOf(
            address(this)
        );
        //console.log(IERC20(output).balanceOf(address(this)));

        if (!isStable) {
            if (output == lpToken0) {
                _swap(output, lpToken1, _outputAmount / 2);
            } else if (output == lpToken1) {
                _swap(output, lpToken0, _outputAmount / 2);
            } else {
                _swap(output, lpToken0, _outputAmount / 2);
                _swap(
                    output,
                    lpToken1,
                    IERC20(output).balanceOf(address(this))
                );
            }
        } else {
            uint256 _amount0In = (_outputAmount * _getRatio(want)) / 10**18;
            uint256 _amount1In = _outputAmount - _amount0In;
            _swap(output, lpToken0, _amount0In);
            _swap(output, lpToken1, _amount1In);
        }

        uint256 _lp0Balance = (lpToken0 != wrapped)
            ? IERC20(lpToken0).balanceOf(address(this))
            : IERC20(lpToken0).balanceOf(address(this)) -
                _lpToken0BalanceBefore;
        uint256 _lp1Balance = (lpToken1 != wrapped)
            ? IERC20(lpToken1).balanceOf(address(this))
            : IERC20(lpToken1).balanceOf(address(this)) -
                _lpToken1BalanceBefore;

        // console.log(lpToken0);
        // console.log(lpToken1);
        // console.log("_lp0Balance", _lp0Balance);
        // console.log("_lp1Balance", _lp1Balance);
        //console.log("_lp0Balance new", _lp0Balance);
        //console.log("_lp1Balance new", _lp1Balance);

        IVelodromeRouter(unirouter).addLiquidity(
            lpToken0,
            lpToken1,
            isStable,
            _lp0Balance,
            _lp1Balance,
            1,
            1,
            address(this),
            block.timestamp
        );
        return IERC20(want).balanceOf(address(this)) - _wantBalanceBefore;
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "./MatrixStrategyBase.sol";
import "./MatrixSwapHelper.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "../interfaces/IUniswapV2Pair.sol";
import "../interfaces/IMasterChef.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

/// @title Base Lp+MasterChef AutoCompound Strategy Framework,
/// all LP strategies will inherit this contract
contract MatrixLpAutoCompound is MatrixStrategyBase, MatrixSwapHelper {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    uint256 public poolId;
    address public masterchef;
    address public output;
    address public lpToken0;
    address public lpToken1;
    address public USDC = 0x04068DA6C83AFCFA0e13ba15A6696662335D5B75;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixStrategyBase(_want, _vault, _treasury)
        MatrixSwapHelper(_uniRouter)
    {
        _initialize(_masterchef, _output, _poolId);
    }

    function _initialize(
        address _masterchef,
        address _output,
        uint256 _poolId
    ) internal virtual {
        masterchef = _masterchef;
        output = _output;
        lpToken0 = IUniswapV2Pair(want).token0();
        lpToken1 = IUniswapV2Pair(want).token1();
        poolId = _poolId;

        _setWhitelistedAddresses();
        _setDefaultSwapPaths();
        _giveAllowances();
    }

    /// @notice Allows strategy governor to setup custom path and dexes for token swaps
    function setSwapPath(
        address _fromToken,
        address _toToken,
        address _unirouter,
        address[] memory _path
    ) external onlyOwner {
        _setSwapPath(_fromToken, _toToken, _unirouter, _path);
    }

    /// @notice Override this to enable other routers or token swap paths
    function _setWhitelistedAddresses() internal virtual {
        whitelistedAddresses.add(unirouter);
        whitelistedAddresses.add(USDC);
        whitelistedAddresses.add(want);
        whitelistedAddresses.add(output);
        whitelistedAddresses.add(wrapped);
        whitelistedAddresses.add(lpToken0);
        whitelistedAddresses.add(lpToken1);
    }

    function _setDefaultSwapPaths() internal virtual {
        // Default output to lp0 paths
        if (lpToken0 == wrapped) {
            address[] memory _path = new address[](2);
            _path[0] = output;
            _path[1] = wrapped;
            _setSwapPath(output, lpToken0, address(0), _path);
        } else if (lpToken0 != output) {
            address[] memory _path = new address[](3);
            _path[0] = output;
            _path[1] = wrapped;
            _path[2] = lpToken0;
            _setSwapPath(output, lpToken0, address(0), _path);
        }

        // Default output to lp1 paths
        if (lpToken1 == wrapped) {
            address[] memory _path = new address[](2);
            _path[0] = output;
            _path[1] = wrapped;
            _setSwapPath(output, lpToken1, address(0), _path);
        } else if (lpToken1 != output) {
            address[] memory _path = new address[](3);
            _path[0] = output;
            _path[1] = wrapped;
            _path[2] = lpToken1;
            _setSwapPath(output, lpToken1, address(0), _path);
        }

        if (output != wrapped) {
            address[] memory _path = new address[](2);
            _path[0] = output;
            _path[1] = wrapped;
            _setSwapPath(output, wrapped, address(0), _path);
        }
    }

    function _giveAllowances() internal override {
        IERC20(want).safeApprove(masterchef, 0);
        IERC20(want).safeApprove(masterchef, type(uint256).max);

        IERC20(output).safeApprove(unirouter, 0);
        IERC20(output).safeApprove(unirouter, type(uint256).max);

        IERC20(lpToken0).safeApprove(unirouter, 0);
        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);

        IERC20(lpToken1).safeApprove(unirouter, 0);
        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);
    }

    function _removeAllowances() internal override {
        IERC20(want).safeApprove(masterchef, 0);
        IERC20(output).safeApprove(unirouter, 0);
        IERC20(lpToken0).safeApprove(unirouter, 0);
        IERC20(lpToken1).safeApprove(unirouter, 0);
    }

    /// @dev total value managed by strategy is want + want staked in MasterChef
    function totalValue() public view virtual override returns (uint256) {
        (uint256 _totalStaked, ) = IMasterChef(masterchef).userInfo(
            poolId,
            address(this)
        );
        return IERC20(want).balanceOf(address(this)) + _totalStaked;
    }

    function _deposit() internal virtual override {
        uint256 _wantBalance = IERC20(want).balanceOf(address(this));
        IMasterChef(masterchef).deposit(poolId, _wantBalance);
    }

    function _beforeWithdraw(uint256 _amout) internal virtual override {
        IMasterChef(masterchef).withdraw(poolId, _amout);
    }

    function _beforeHarvest() internal virtual {
        IMasterChef(masterchef).deposit(poolId, 0);
    }

    function _harvest()
        internal
        virtual
        override
        returns (uint256 _wantHarvested, uint256 _wrappedFeesAccrued)
    {
        _beforeHarvest();
        uint256 _outputBalance = IERC20(output).balanceOf(address(this));
        if (_outputBalance > 0) {
            if (output != wrapped) {
                _wrappedFeesAccrued = _swap(
                    output,
                    wrapped,
                    (_outputBalance * totalFee) / PERCENT_DIVISOR
                );
                _outputBalance = IERC20(output).balanceOf(address(this));
            } else {
                _wrappedFeesAccrued =
                    (_outputBalance * totalFee) /
                    PERCENT_DIVISOR;
                _outputBalance -= _wrappedFeesAccrued;
            }
            _wantHarvested = _addLiquidity(_outputBalance);
            
            if (lpToken0 == wrapped || lpToken1 == wrapped) {
                // Anything left here in wrapped after adding liquidity
                // Are fees accrued
                _wrappedFeesAccrued = IERC20(wrapped).balanceOf(address(this));
            }
        }
    }

    function _addLiquidity(uint256 _outputAmount)
        internal
        virtual
        returns (uint256 _wantHarvested)
    {
        uint256 _wantBalanceBefore = IERC20(want).balanceOf(address(this));
        uint256 _lpToken0BalanceBefore = IERC20(lpToken0).balanceOf(
            address(this)
        );
        uint256 _lpToken1BalanceBefore = IERC20(lpToken1).balanceOf(
            address(this)
        );
        if (output == lpToken0) {
            _swap(output, lpToken1, _outputAmount / 2);
        } else if (output == lpToken1) {
            _swap(output, lpToken0, _outputAmount / 2);
        } else {
            _swap(output, lpToken0, _outputAmount / 2);
            _swap(output, lpToken1, IERC20(output).balanceOf(address(this)));
        }

        uint256 _lp0Balance = (lpToken0 != wrapped)
            ? IERC20(lpToken0).balanceOf(address(this))
            : IERC20(lpToken0).balanceOf(address(this)) -
                _lpToken0BalanceBefore;
        uint256 _lp1Balance = (lpToken1 != wrapped)
            ? IERC20(lpToken1).balanceOf(address(this))
            : IERC20(lpToken1).balanceOf(address(this)) -
                _lpToken1BalanceBefore;

        IUniswapV2Router02(unirouter).addLiquidity(
            lpToken0,
            lpToken1,
            _lp0Balance,
            _lp1Balance,
            1,
            1,
            address(this),
            block.timestamp
        );
        return IERC20(want).balanceOf(address(this)) - _wantBalanceBefore;
    }

    function _beforePanic() internal virtual override {
        IMasterChef(masterchef).emergencyWithdraw(poolId);
    }

    /// @dev _beforeRetireStrat behaves exactly like _beforePanic hook
    function _beforeRetireStrat() internal override {
        _beforePanic();
    }
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

interface IGauge {

    function deposit(uint256 _amount, uint256 _tokenId) external;
    function depositAll(uint256 _tokenId) external;
    function withdraw(uint _amount) external;
    function withdrawAll() external;
    function claimFees() external;
    function getReward(address _account, address[] memory _tokens) external;
    function earned(address _token, address _account) external view returns (uint256);
    function balanceOf(address _from) external view returns (uint256);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../interfaces/IMatrixStrategy.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";

/// @title Base Strategy Framework, all strategies will inherit this
abstract contract MatrixStrategyBase is Ownable, Pausable {
    using SafeERC20 for IERC20;

    // Matrix contracts
    address public immutable vault;
    address public treasury;
    address public partner;

    // Tokens used
    address public wrapped =
        address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);
    address public immutable want;

    uint256 public callFee = 1000;
    uint256 public partnerFee = 0;
    uint256 public treasuryFee = 9000;
    uint256 public securityFee = 10;
    uint256 public totalFee = 450;

    /***
     * {MAX_FEE} - Maximum fee allowed by the strategy. Hard-capped at 5%.
     * {PERCENT_DIVISOR} - Constant used to safely calculate the correct percentages.
     */

    uint256 public constant MAX_FEE = 500;
    uint256 public constant PERCENT_DIVISOR = 10000;

    /**
     * {Harvested} Event that is fired each time someone harvests the strat.
     * {TotalFeeUpdated} Event that is fired each time the total fee is updated.
     * {CallFeeUpdated} Event that is fired each time the call fee is updated.
     * {TreasuryUpdated} Event that is fired each time treasury address is updated.
     */
    event Harvested(
        address indexed harvester,
        uint256 _wantHarvested,
        uint256 _totalValueBefore,
        uint256 _totalValueAfter
    );
    event TotalFeeUpdated(uint256 newFee);
    event CallFeeUpdated(uint256 newCallFee, uint256 newTreasuryFee);
    event SecurityFeeUpdated(uint256 newSecurityFee);
    event PartnerFeeUpdated(uint256 newPartnerFee, uint256 newTreasuryFee);

    event TreasuryUpdated(
        address indexed _oldTreasury,
        address indexed _newTreasury
    );

    modifier onlyVault() {
        require(msg.sender == vault, "!vault");
        _;
    }

    constructor(
        address _want,
        address _vault,
        address _treasury
    ) {
        require(_vault != address(0), "vault-is-zero");
        require(_treasury != address(0), "treasury-is-zero");
        require(_want != address(0), "want-is-zero");

        vault = _vault;
        treasury = _treasury;
        want = _want;
    }

    /**
     * @dev updates the total fee, capped at 5%
     */
    function updateTotalFee(uint256 _totalFee)
        external
        onlyOwner
        returns (bool)
    {
        require(_totalFee <= MAX_FEE, "fee-too-high");
        totalFee = _totalFee;
        emit TotalFeeUpdated(totalFee);
        return true;
    }

    /**
     * @dev updates security fee, capped at 5%
     */
    function updateSecurityFee(uint256 _securityFee)
        external
        onlyOwner
        returns (bool)
    {
        require(_securityFee <= MAX_FEE, "fee-too-high");
        securityFee = _securityFee;
        emit SecurityFeeUpdated(securityFee);
        return true;
    }

    /**
     * @dev updates the call fee and adjusts the treasury fee to cover the difference
     */
    function updateCallFee(uint256 _callFee) external onlyOwner returns (bool) {
        callFee = _callFee;
        treasuryFee = PERCENT_DIVISOR - callFee - partnerFee;
        emit CallFeeUpdated(callFee, treasuryFee);
        return true;
    }

    /**
     * @dev updates the partner fee and adjusts the treasury fee to cover the difference
     */
    function updatePartnerFee(uint256 _partnerFee) external onlyOwner returns (bool) {
        require(partner != address(0), "partner-not-set");

        partnerFee = _partnerFee;
        treasuryFee = PERCENT_DIVISOR - partnerFee - callFee;
        emit PartnerFeeUpdated(partnerFee, treasuryFee);
        return true;
    }

    function updateTreasury(address _newTreasury)
        external
        onlyOwner
        returns (bool)
    {
        require(_newTreasury != address(0), "treasury-is-zero");
        treasury = _newTreasury;
        return true;
    }

    function updatePartner(address _newPartner)
        external
        onlyOwner
        returns (bool)
    {
        require(_newPartner != address(0), "partner-is-zero");
        partner = _newPartner;
        return true;
    }

    /**
     * @dev Puts funds in strategy at work
     * @notice Only vault can call this when not paused
     */
    function deposit() external virtual whenNotPaused onlyVault {
        _deposit();
    }

    function withdraw(uint256 _amount) external virtual onlyVault {
        uint256 _balanceHere = IERC20(want).balanceOf(address(this));

        if (_balanceHere < _amount) {
            _beforeWithdraw(_amount - _balanceHere);
            _balanceHere = IERC20(want).balanceOf(address(this));
        }

        if (_balanceHere > _amount) {
            _balanceHere = _amount;
        }
        uint256 _withdrawFee = (_balanceHere * securityFee) / PERCENT_DIVISOR;
        IERC20(want).safeTransfer(vault, _balanceHere - _withdrawFee);
    }

    function pause() external virtual onlyOwner {
        _pause();
        _removeAllowances();
    }

    function unpause() external virtual onlyOwner {
        _unpause();
        _giveAllowances();
        _deposit();
    }

    function beforeDeposit() external virtual onlyVault {}

    function retireStrat() external onlyVault {
        _beforeRetireStrat();
        uint256 _wantBalance = IERC20(want).balanceOf(address(this));
        IERC20(want).safeTransfer(vault, _wantBalance);
    }

    /// @notice pauses deposits and withdraws all funds from third party systems.
    function panic() external onlyOwner {
        _pause();
        _beforePanic();
    }

    /// @notice compounds earnings and charges performance fee
    function harvest() external whenNotPaused {
        require(!Address.isContract(msg.sender), "!contract");

        uint256 _totalValueBefore = totalValue();
        (uint256 _wantHarvested, uint256 _wrappedFeesAccrued) = _harvest();

        _chargeFees(_wrappedFeesAccrued);

        uint256 _totalValueAfter = totalValue();
        _deposit();

        emit Harvested(
            msg.sender,
            _wantHarvested,
            _totalValueBefore,
            _totalValueAfter
        );
    }

    /// @notice "want" Funds held in strategy + funds deployed elsewhere
    function totalValue() public virtual view returns (uint256) {
        return IERC20(want).balanceOf(address(this));
    }

    /// @notice For vault interface retro-compatibility
    function balanceOf() public virtual view returns (uint256) {
        return totalValue();
    }
 
    function _chargeFees(uint256 _wrappedFeesAccrued) internal virtual {
        uint256 _callFeeToUser = (_wrappedFeesAccrued * callFee) /
            PERCENT_DIVISOR;

        uint256 _feeToPartner = (_wrappedFeesAccrued * partnerFee) /
            PERCENT_DIVISOR;

        IERC20(wrapped).safeTransfer(msg.sender, _callFeeToUser);
        IERC20(wrapped).safeTransfer(
            treasury,
            _wrappedFeesAccrued - _callFeeToUser - _feeToPartner
        );

        if(partner != address(0)) {
            IERC20(wrapped).safeTransfer(
                partner, 
                _feeToPartner
            );
        }
    }

    /// @notice Hooks to customize strategies behavior
    function _deposit() internal virtual {}

    function _beforeWithdraw(uint256 _amount) internal virtual {}

    function _harvest()
        internal
        virtual
        returns (uint256 _wantHarvested, uint256 _wrappedFeesAccrued)
    {}

    function _giveAllowances() internal virtual {}
    function _removeAllowances() internal virtual {}
    function _beforeRetireStrat() internal virtual {}
    function _beforePanic() internal virtual {}
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

interface IMasterChef {
    function pendingShare(uint256 _pid, address _user)
        external
        view
        returns (uint256);

    function deposit(uint256 _pid, uint256 _amount) external;
    function deposit(uint256 _pid, uint256 _amount, address _to) external;
    function harvest(uint256 _pid, address _to) external;
    function poolLength() external view returns (uint256);
    function poolInfo(uint256 _pid) external view returns (address, uint32, uint8, uint256, uint256, uint256, uint256, uint256, address, uint32, uint32, uint32);
    function withdraw(uint256 _pid, uint256 _amount) external;
    function stakeAndUnstakeMagicats(uint _pid, uint[] memory stakeTokenIDs, uint[] memory unstakeTokenIDs) external;
    function getStakedMagicats(uint _pid, address _user) external view returns (uint[] memory);
    function withdrawAndHarvest(uint256 _pid, uint256 _amount, address _to) external;

    function withdrawAndHarvestShort(uint256 _pid, uint128 _amount) external;
    function harvestShort(uint256 _pid) external;
    function depositShort(uint256 _pid, uint128 _amount) external;
    function userInfo(uint256 _pid, address _user)
        external
        view
        returns (uint256, uint256);

    function emergencyWithdraw(uint256 _pid) external;
    function withdrawAll(uint256 _pid) external;

    function emergencyWithdraw(uint256 _pid, address _to) external;
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IMatrixStrategy {
    function vault() external view returns (address);

    function want() external view returns (IERC20);

    function beforeDeposit() external;

    function deposit() external;

    function withdraw(uint256) external;

    function balanceOf() external view returns (uint256);

    function harvest() external;

    function retireStrat() external;

    function panic() external;

    function pause() external;

    function unpause() external;

    function paused() external view returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable is Context {
    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address account);

    bool private _paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    constructor() {
        _paused = false;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view virtual returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        require(!paused(), "Pausable: paused");
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        require(paused(), "Pausable: not paused");
        _;
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixStrategyBase.sol";
import "../MatrixSwapHelper.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "../../interfaces/IUniswapV2Pair.sol";
import "../../interfaces/radiant/IMultiFeeDistribution.sol";
import "../../interfaces/radiant/rToken.sol";
import "../../interfaces/radiant/rPool.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
//import "hardhat/console.sol";

/// @title Radiant Single Staking autocompounder strategy
contract RadiantMatrixSingleAutoCompound is
    MatrixStrategyBase,
    MatrixSwapHelper
{
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    uint256 public poolId;
    address public masterchef;
    address public output;
    address public USDC = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8;
    uint256 public rewardsLength = 6;

    uint256 public lastTotalValue;
    uint256 public lastHarvestTime;
    uint256 public rewardApr;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixStrategyBase(_want, _vault, _treasury)
        MatrixSwapHelper(_uniRouter)
    {
        _initialize(_masterchef, _output, _poolId);
        lastHarvestTime = block.timestamp;
    }

    function _initialize(
        address _masterchef,
        address _output,
        uint256 _poolId
    ) internal virtual {
        masterchef = _masterchef;
        output = _output;
        poolId = _poolId;
        wrapped = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;
        treasury = 0xEaD9f532C72CF35dAb18A42223eE7A1B19bC5aBF;

        _setWhitelistedAddresses();
        _setDefaultSwapPaths();
        _giveAllowances();
    }

    /// @notice Allows strategy governor to setup custom path and dexes for token swaps
    function setSwapPath(
        address _fromToken,
        address _toToken,
        address _unirouter,
        address[] memory _path
    ) external onlyOwner {
        _setSwapPath(_fromToken, _toToken, _unirouter, _path);
    }

    /// @notice Override this to enable other routers or token swap paths
    function _setWhitelistedAddresses() internal virtual {
        whitelistedAddresses.add(unirouter);
        whitelistedAddresses.add(USDC);
        whitelistedAddresses.add(want);
        whitelistedAddresses.add(output);
        whitelistedAddresses.add(wrapped);

        for (uint256 i = 1; i < rewardsLength; i++) {
            address _rToken = IMultiFeeDistribution(masterchef).rewardTokens(i);
            address _underlying = rToken(_rToken).UNDERLYING_ASSET_ADDRESS();
            whitelistedAddresses.add(_underlying);
        }
    }

    function _setDefaultSwapPaths() internal virtual {
        for (uint256 i = 0; i < rewardsLength; i++) {
            address _token = IMultiFeeDistribution(masterchef).rewardTokens(i);
            if (i > 0) {
                address _underlying = rToken(_token).UNDERLYING_ASSET_ADDRESS();
                _token = _underlying;
            }
            if (_token == wrapped) {
                address[] memory _path = new address[](2);
                _path[0] = _token;
                _path[1] = output;
                _setSwapPath(_token, output, unirouter, _path);
            } else if (_token != output) {
                address[] memory _path = new address[](3);
                _path[0] = _token;
                _path[1] = wrapped;
                _path[2] = output;
                _setSwapPath(_token, output, unirouter, _path);
            }
        }

        address[] memory _path = new address[](2);
        _path[0] = output;
        _path[1] = wrapped;
        _setSwapPath(output, wrapped, unirouter, _path);
    }

    function _giveAllowances() internal override {
        IERC20(want).safeApprove(masterchef, 0);
        IERC20(want).safeApprove(masterchef, type(uint256).max);
    }

    function _removeAllowances() internal override {
        IERC20(want).safeApprove(masterchef, 0);
    }

    /// @dev total value managed by strategy is want + want staked in MasterChef
    function totalValue() public view virtual override returns (uint256) {
        return IERC20(want).balanceOf(address(this)) + _getStakedValue();
    }

    function setRewardsLength(uint256 _rewardsLength) external onlyOwner {
        require(_rewardsLength > 0, "invalid-rewards-length");
        rewardsLength = _rewardsLength;
        _setWhitelistedAddresses();
        _setDefaultSwapPaths();
    }

    function withdrawable() public view virtual returns (uint256 _unlocked) {
        (, _unlocked, , ) = IMultiFeeDistribution(masterchef).lockedBalances(
            address(this)
        );
    }

    function _getStakedValue() internal view returns (uint256 _total) {
        (_total, , , ) = IMultiFeeDistribution(masterchef).lockedBalances(
            address(this)
        );
    }

    function _deposit() internal virtual override {
        uint256 _rdntBalance = IERC20(want).balanceOf(address(this));
        if (_rdntBalance > 0)
            IMultiFeeDistribution(masterchef).stake(
                _rdntBalance,
                true,
                address(this)
            );
    }

    function _beforeWithdraw(uint256 _amount) internal virtual override {
        require(_amount <= withdrawable(), "not-enough-withdrawable-balance");
        IMultiFeeDistribution(masterchef).withdrawExpiredLocks();
    }

    function _beforeHarvest() internal virtual {}

    function _harvest()
        internal
        virtual
        override
        returns (uint256 _wantHarvested, uint256 _wrappedFeesAccrued)
    {
        _beforeHarvest();
        lastTotalValue = totalValue();
        uint256 _rdntBalanceBefore = IERC20(output).balanceOf(address(this));
        address[] memory _rewardTokens = new address[](rewardsLength);
        for (uint256 i = 0; i < rewardsLength; i++) {
            _rewardTokens[i] = IMultiFeeDistribution(masterchef).rewardTokens(
                i
            );
        }
        IMultiFeeDistribution(masterchef).getReward(_rewardTokens);

        for (uint256 i = 0; i < rewardsLength; i++) {
            address _token = _rewardTokens[i];
            if (i > 0) {
                address _underlying = rToken(_rewardTokens[i])
                    .UNDERLYING_ASSET_ADDRESS();
                address _pool = rToken(_rewardTokens[i]).POOL();
                if (IERC20(_rewardTokens[i]).balanceOf(address(this)) > 0) {
                    rPool(_pool).withdraw(
                        _underlying,
                        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,
                        address(this)
                    );
                    _token = _underlying;
                } else {
                    continue;
                }
            }
            _swap(_token, output, IERC20(_token).balanceOf(address(this)));
        }

        uint256 _outputBalance = IERC20(output).balanceOf(address(this)) -
            _rdntBalanceBefore;

        uint256 _elapsedFromLastHarvest = block.timestamp - lastHarvestTime;
        uint256 _rewardPerSecond = (_outputBalance * 1e18) /
            _elapsedFromLastHarvest;
        uint256 _rewardPerDay = _rewardPerSecond * 86400;
        rewardApr = (_rewardPerDay * 365) / lastTotalValue;
        lastHarvestTime = block.timestamp;

        if (_outputBalance > 0) {
            _wrappedFeesAccrued = _swap(
                output,
                wrapped,
                (_outputBalance * totalFee) / PERCENT_DIVISOR
            );
            _wantHarvested =
                IERC20(output).balanceOf(address(this)) -
                _rdntBalanceBefore;
        }
    }

    function _beforePanic() internal virtual override {
        uint256 _staked = _getStakedValue();
        IMultiFeeDistribution(masterchef).withdrawExpiredLocks();
        require(
            IERC20(want).balanceOf(address(this)) >= _staked,
            "panic-failed"
        );
    }

    /// @dev _beforeRetireStrat behaves exactly like _beforePanic hook
    function _beforeRetireStrat() internal override {
        _beforePanic();
    }
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;
struct LockedBalance {
    uint256 amount;
    uint256 unlockTime;
}

interface IMultiFeeDistribution {
    function addReward(address rewardsToken) external;

    function mint(
        address user,
        uint256 amount,
        bool withPenalty
    ) external;

    function exit(bool claimRewards, address onBehalfOf) external;

    function stake(
        uint256 amount,
        bool lock,
        address onBehalfOf
    ) external;

    function lockedBalances(address user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        );

    function getReward(address[] memory _rewardTokens) external;

    function rewardTokens(uint256 _index) external view returns (address);

    function withdrawExpiredLocks() external;

    function withdraw(uint256 _amount) external;

    function withdrawableBalance(address user)
        external
        view
        returns (uint256 amount, uint256 penaltyAmount);
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface rToken is IERC20 {
    function UNDERLYING_ASSET_ADDRESS() external view returns (address);
    function POOL() external view returns (address);
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface rPool {
    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external;
}

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "./interfaces/IUniswapV2Pair.sol";
import "./interfaces/IWETH.sol";
import "./interfaces/IMatrixVault.sol";
import "./strategies/MatrixSwapHelper.sol";

contract ZapperDogechain is MatrixSwapHelper, Ownable {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    event DefaultRouterChanged(
        address indexed _oldRouter,
        address indexed _newRouter
    );
    event CustomRouterSet(
        address indexed _lpToken,
        address indexed _customRouter
    );

    event ZapIn(
        address indexed _user,
        address indexed _vault,
        address indexed _want,
        uint256 _amountIn
    );

    event ZapOut(
        address indexed _user,
        address indexed _vault,
        address indexed _want,
        uint256 _amountOut
    );

    string public constant VERSION = "1.2";

    address public constant WETH = 0xB7ddC6414bf4F5515b52D8BdD69973Ae205ff101;
    address internal constant KIBBLESWAP_ROUTER = 0x6258c967337D3faF0C2ba3ADAe5656bA95419d5f;
    /// @dev Mapping of LP ERC20 -> Router
    /// In order to support a wider range of UniV2 forks
    mapping(address => address) public customRouter;

    /// @dev Mapping of Factory -> Router to retrieve
    /// the default router for LP token
    mapping(address => address) public factoryToRouter;

    /// @dev Default router for LP Tokens
    address public defaultRouter;

    /// @notice KibbleSwap ROUTER AS DEFAULT FOR LP TOKENS AND SWAPS
    constructor() MatrixSwapHelper(KIBBLESWAP_ROUTER) {
        /// Default router to put LPs in:
        _setDefaultRouter(KIBBLESWAP_ROUTER);

        // Factory to Router
        // KibbleSwap Optimism
        factoryToRouter[
            0xF4bc79D32A7dEfd87c8A9C100FD83206bbF19Af5
        ] = 0x6258c967337D3faF0C2ba3ADAe5656bA95419d5f;
    }

    receive() external payable {}

    /// @notice Get swap custom swap paths, if any
    /// @dev Otherwise reverts to default FROMTOKEN-WETH-TOTOKEN behavior
    function getSwapPath(address _fromToken, address _toToken)
        public
        view
        override
        returns (SwapPath memory _swapPath)
    {
        bytes32 _swapKey = keccak256(abi.encodePacked(_fromToken, _toToken));
        if (swapPaths[_swapKey].path.length == 0) {
            if (_fromToken != WETH && _toToken != WETH) {
                address[] memory _path = new address[](3);
                _path[0] = _fromToken;
                _path[1] = WETH;
                _path[2] = _toToken;
                _swapPath.path = _path;
            } else {
                address[] memory _path = new address[](2);
                _path[0] = _fromToken;
                _path[1] = _toToken;
                _swapPath.path = _path;
            }
            _swapPath.unirouter = unirouter;
        } else {
            return swapPaths[_swapKey];
        }
    }

    /// @dev Allows owner to set a custom swap path from a token to another
    /// @param _unirouter Can also set a custom unirouter for the swap, or address(0) for default router (spooky)
    function setSwapPath(
        address _fromToken,
        address _toToken,
        address _unirouter,
        address[] memory _path
    ) external onlyOwner {
        _setSwapPath(_fromToken, _toToken, _unirouter, _path);
    }

    function zapToLp(
        address _fromToken,
        address _toLpToken,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) external payable {
        uint256 _lpAmountOut = _zapToLp(
            _fromToken,
            _toLpToken,
            _amountIn,
            _minLpAmountOut
        );

        IERC20(_toLpToken).safeTransfer(msg.sender, _lpAmountOut);
    }

    function zapToMatrix(
        address _fromToken,
        address _matrixVault,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) external payable {
        IMatrixVault _vault = IMatrixVault(_matrixVault);
        address _toLpToken = _vault.want();

        uint256 _lpAmountOut = _zapToLp(
            _fromToken,
            _toLpToken,
            _amountIn,
            _minLpAmountOut
        );

        uint256 _vaultBalanceBefore = _vault.balanceOf(address(this));
        IERC20(_toLpToken).safeApprove(_matrixVault, _lpAmountOut);
        _vault.deposit(_lpAmountOut);
        uint256 _vaultAmountOut = _vault.balanceOf(address(this)) -
            _vaultBalanceBefore;
        require(_vaultAmountOut > 0, "deposit-in-vault-failed");
        _vault.transfer(msg.sender, _vaultAmountOut);

        emit ZapIn(msg.sender, address(_vault), _toLpToken, _lpAmountOut);
    }

    function unzapFromMatrix(
        address _matrixVault,
        address _toToken,
        uint256 _withdrawAmount,
        uint256 _minAmountOut
    ) external {
        IMatrixVault _vault = IMatrixVault(_matrixVault);
        address _fromLpToken = _vault.want();

        _vault.transferFrom(msg.sender, address(this), _withdrawAmount);
        _vault.withdraw(_withdrawAmount);

        uint256 _amountOut = _unzapFromLp(
            _fromLpToken,
            _toToken,
            IERC20(_fromLpToken).balanceOf(address(this)),
            _minAmountOut
        );

        emit ZapOut(msg.sender, address(_vault), _fromLpToken, _amountOut);
    }

    function unzapFromLp(
        address _fromLpToken,
        address _toToken,
        uint256 _amountLpIn,
        uint256 _minAmountOut
    ) external {
        IERC20(_fromLpToken).safeTransferFrom(
            msg.sender,
            address(this),
            _amountLpIn
        );
        _unzapFromLp(_fromLpToken, _toToken, _amountLpIn, _minAmountOut);
    }

    /// @notice In case tokens got stuck/mistakenly sent here
    function sweepERC20(address _token) external onlyOwner {
        IERC20(_token).safeTransfer(
            msg.sender,
            IERC20(_token).balanceOf(_token)
        );
    }

    function setDefaultRouter(address _newDefaultRouter) external onlyOwner {
        _setDefaultRouter(_newDefaultRouter);
    }

    function setCustomRouter(address _token, address _router)
        external
        onlyOwner
    {
        require(_token != address(0), "invalid-token-addr");
        require(_router != defaultRouter, "invalid-custom-router");
        emit CustomRouterSet(_token, _router);
        customRouter[_token] = _router;
    }

    function _setDefaultRouter(address _newDefaultRouter) internal {
        require(_newDefaultRouter != address(0), "invalid-default-router");
        emit DefaultRouterChanged(defaultRouter, _newDefaultRouter);
        defaultRouter = _newDefaultRouter;
    }

    function addRouter(address _factory, address _router) external onlyOwner {
        require(factoryToRouter[_factory] == address(0), "already-set");

        factoryToRouter[_factory] = _router;
    }

    /// @notice Get router for LPToken
    function _getRouter(address _lpToken)
        internal
        view
        virtual
        returns (address)
    {
        if (customRouter[_lpToken] != address(0)) return customRouter[_lpToken];

        address _factory = IUniswapV2Pair(_lpToken).factory();
        require(factoryToRouter[_factory] != address(0), "unsupported-router");

        return factoryToRouter[_factory];
    }

    function _zapToLp(
        address _fromToken,
        address _toLpToken,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) internal virtual returns (uint256 _lpAmountOut) {
        if (msg.value > 0) {
            // If you send FTM instead of WETH these requirements must hold.
            require(_fromToken == WETH, "invalid-from-token");
            require(_amountIn == msg.value, "invalid-amount-in");
            // Auto-wrap FTM to WETH
            IWETH(WETH).deposit{value: msg.value}();
        } else {
            IERC20(_fromToken).safeTransferFrom(
                msg.sender,
                address(this),
                _amountIn
            );
        }

        address _router = _getRouter(_toLpToken);

        IERC20(_fromToken).safeApprove(_router, 0);
        IERC20(_fromToken).safeApprove(_router, _amountIn);

        address _token0 = IUniswapV2Pair(_toLpToken).token0();
        address _token1 = IUniswapV2Pair(_toLpToken).token1();

        address _defaultRouter = unirouter;
        unirouter = _router;
        // Uses lpToken' _router as the default router
        // You can override this by using setting a custom path
        // Using setSwapPath

        uint256 _token0Out = _swap(_fromToken, _token0, _amountIn / 2);
        uint256 _token1Out = _swap(
            _fromToken,
            _token1,
            _amountIn - (_amountIn / 2)
        );

        // Revert back to defaultRouter for swaps
        unirouter = _defaultRouter;

        IERC20(_token0).safeApprove(_router, 0);
        IERC20(_token1).safeApprove(_router, 0);
        IERC20(_token0).safeApprove(_router, _token0Out);
        IERC20(_token1).safeApprove(_router, _token1Out);

        uint256 _lpBalanceBefore = IERC20(_toLpToken).balanceOf(address(this));

        _addLiquidity(_router, _token0, _token1, _token0Out, _token1Out, false);

        _lpAmountOut =
            IERC20(_toLpToken).balanceOf(address(this)) -
            _lpBalanceBefore;
        require(_lpAmountOut >= _minLpAmountOut, "slippage-rekt-you");
    }

    function _addLiquidity(
        address _router,
        address _token0,
        address _token1,
        uint256 _token0Out,
        uint256 _token1Out,
        bool _stable
    ) internal virtual {
        IUniswapV2Router02(_router).addLiquidity(
            _token0,
            _token1,
            _token0Out,
            _token1Out,
            0,
            0,
            address(this),
            block.timestamp
        );
    }

    function _removeLiquidity(
        address _router,
        address _token0,
        address _token1,
        uint256 _amountLpIn,
        bool _stable
    ) internal virtual {
        IUniswapV2Router02(_router).removeLiquidity(
            _token0,
            _token1,
            _amountLpIn,
            0,
            0,
            address(this),
            block.timestamp
        );
    }

    function _unzapFromLp(
        address _fromLpToken,
        address _toToken,
        uint256 _amountLpIn,
        uint256 _minAmountOut
    ) internal virtual returns (uint256 _amountOut) {
        address _router = _getRouter(_fromLpToken);

        address _token0 = IUniswapV2Pair(_fromLpToken).token0();
        address _token1 = IUniswapV2Pair(_fromLpToken).token1();

        IERC20(_fromLpToken).safeApprove(_router, 0);
        IERC20(_fromLpToken).safeApprove(_router, _amountLpIn);

        _removeLiquidity(_router, _token0, _token1, _amountLpIn, false);

        address _defaultRouter = unirouter;
        unirouter = _router;
        // Uses lpToken' _router as the default router
        // You can override this by using setting a custom path
        // Using setSwapPath

        _swap(_token0, _toToken, IERC20(_token0).balanceOf(address(this)));
        _swap(_token1, _toToken, IERC20(_token1).balanceOf(address(this)));

        // Revert back to defaultRouter for swaps
        unirouter = _defaultRouter;

        _amountOut = IERC20(_toToken).balanceOf(address(this));

        require(_amountOut >= _minAmountOut, "slippage-rekt-you");

        if (_toToken == WETH) {
            IWETH(WETH).withdraw(_amountOut);

            (bool _success, ) = msg.sender.call{value: _amountOut}("");
            require(_success, "eth-transfer-failed");
        } else {
            IERC20(_toToken).transfer(msg.sender, _amountOut);
        }
    }

    function _checkPath(address[] memory _path) internal override {}

    function _checkRouter(address _router) internal override {}
}

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "./interfaces/IUniswapV2Pair.sol";
import "./interfaces/IWETH.sol";
import "./interfaces/IMatrixVault.sol";
import "./strategies/MatrixSwapHelper.sol";

contract ZapperArbitrum is MatrixSwapHelper, Ownable {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    event DefaultRouterChanged(
        address indexed _oldRouter,
        address indexed _newRouter
    );
    event CustomRouterSet(
        address indexed _lpToken,
        address indexed _customRouter
    );

    event ZapIn(
        address indexed _user,
        address indexed _vault,
        address indexed _want,
        uint256 _amountIn
    );

    event ZapOut(
        address indexed _user,
        address indexed _vault,
        address indexed _want,
        uint256 _amountOut
    );

    string public constant VERSION = "1.2";

    address public constant WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;
    address internal constant SUSHISWAP_ROUTER =
        0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;
    /// @dev Mapping of LP ERC20 -> Router
    /// In order to support a wider range of UniV2 forks
    mapping(address => address) public customRouter;

    /// @dev Mapping of Factory -> Router to retrieve
    /// the default router for LP token
    mapping(address => address) public factoryToRouter;

    /// @dev Default router for LP Tokens
    address public defaultRouter;

    /// @notice SushiSwap ROUTER AS DEFAULT FOR LP TOKENS AND SWAPS
    constructor() MatrixSwapHelper(SUSHISWAP_ROUTER) {
        /// Default router to put LPs in:
        _setDefaultRouter(SUSHISWAP_ROUTER);

        // Factory to Router
        // SushiSwap Arbitrum
        factoryToRouter[
            0xc35DADB65012eC5796536bD9864eD8773aBc74C4
        ] = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;
    }

    receive() external payable {}

    /// @notice Get swap custom swap paths, if any
    /// @dev Otherwise reverts to default FROMTOKEN-WETH-TOTOKEN behavior
    function getSwapPath(address _fromToken, address _toToken)
        public
        view
        override
        returns (SwapPath memory _swapPath)
    {
        bytes32 _swapKey = keccak256(abi.encodePacked(_fromToken, _toToken));
        if (swapPaths[_swapKey].path.length == 0) {
            if (_fromToken != WETH && _toToken != WETH) {
                address[] memory _path = new address[](3);
                _path[0] = _fromToken;
                _path[1] = WETH;
                _path[2] = _toToken;
                _swapPath.path = _path;
            } else {
                address[] memory _path = new address[](2);
                _path[0] = _fromToken;
                _path[1] = _toToken;
                _swapPath.path = _path;
            }
            _swapPath.unirouter = unirouter;
        } else {
            return swapPaths[_swapKey];
        }
    }

    /// @dev Allows owner to set a custom swap path from a token to another
    /// @param _unirouter Can also set a custom unirouter for the swap, or address(0) for default router (spooky)
    function setSwapPath(
        address _fromToken,
        address _toToken,
        address _unirouter,
        address[] memory _path
    ) external onlyOwner {
        _setSwapPath(_fromToken, _toToken, _unirouter, _path);
    }

    function zapToLp(
        address _fromToken,
        address _toLpToken,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) external payable {
        uint256 _lpAmountOut = _zapToLp(
            _fromToken,
            _toLpToken,
            _amountIn,
            _minLpAmountOut
        );

        IERC20(_toLpToken).safeTransfer(msg.sender, _lpAmountOut);
    }

    function zapToMatrix(
        address _fromToken,
        address _matrixVault,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) external payable {
        IMatrixVault _vault = IMatrixVault(_matrixVault);
        address _toLpToken = _vault.want();

        uint256 _lpAmountOut = _zapToLp(
            _fromToken,
            _toLpToken,
            _amountIn,
            _minLpAmountOut
        );

        uint256 _vaultBalanceBefore = _vault.balanceOf(address(this));
        IERC20(_toLpToken).safeApprove(_matrixVault, _lpAmountOut);
        _vault.deposit(_lpAmountOut);
        uint256 _vaultAmountOut = _vault.balanceOf(address(this)) -
            _vaultBalanceBefore;
        require(_vaultAmountOut > 0, "deposit-in-vault-failed");
        _vault.transfer(msg.sender, _vaultAmountOut);

        emit ZapIn(msg.sender, address(_vault), _toLpToken, _lpAmountOut);
    }

    function unzapFromMatrix(
        address _matrixVault,
        address _toToken,
        uint256 _withdrawAmount,
        uint256 _minAmountOut
    ) external {
        IMatrixVault _vault = IMatrixVault(_matrixVault);
        address _fromLpToken = _vault.want();

        _vault.transferFrom(msg.sender, address(this), _withdrawAmount);
        _vault.withdraw(_withdrawAmount);

        uint256 _amountOut = _unzapFromLp(
            _fromLpToken,
            _toToken,
            IERC20(_fromLpToken).balanceOf(address(this)),
            _minAmountOut
        );

        emit ZapOut(msg.sender, address(_vault), _fromLpToken, _amountOut);
    }

    function unzapFromLp(
        address _fromLpToken,
        address _toToken,
        uint256 _amountLpIn,
        uint256 _minAmountOut
    ) external {
        IERC20(_fromLpToken).safeTransferFrom(
            msg.sender,
            address(this),
            _amountLpIn
        );
        _unzapFromLp(_fromLpToken, _toToken, _amountLpIn, _minAmountOut);
    }

    /// @notice In case tokens got stuck/mistakenly sent here
    function sweepERC20(address _token) external onlyOwner {
        IERC20(_token).safeTransfer(
            msg.sender,
            IERC20(_token).balanceOf(_token)
        );
    }

    function setDefaultRouter(address _newDefaultRouter) external onlyOwner {
        _setDefaultRouter(_newDefaultRouter);
    }

    function setCustomRouter(address _token, address _router)
        external
        onlyOwner
    {
        require(_token != address(0), "invalid-token-addr");
        require(_router != defaultRouter, "invalid-custom-router");
        emit CustomRouterSet(_token, _router);
        customRouter[_token] = _router;
    }

    function _setDefaultRouter(address _newDefaultRouter) internal {
        require(_newDefaultRouter != address(0), "invalid-default-router");
        emit DefaultRouterChanged(defaultRouter, _newDefaultRouter);
        defaultRouter = _newDefaultRouter;
    }

    function addRouter(address _factory, address _router) external onlyOwner {
        require(factoryToRouter[_factory] == address(0), "already-set");

        factoryToRouter[_factory] = _router;
    }

    /// @notice Get router for LPToken
    function _getRouter(address _lpToken)
        internal
        view
        virtual
        returns (address)
    {
        if (customRouter[_lpToken] != address(0)) return customRouter[_lpToken];

        address _factory = IUniswapV2Pair(_lpToken).factory();
        require(factoryToRouter[_factory] != address(0), "unsupported-router");

        return factoryToRouter[_factory];
    }

    function _zapToLp(
        address _fromToken,
        address _toLpToken,
        uint256 _amountIn,
        uint256 _minLpAmountOut
    ) internal virtual returns (uint256 _lpAmountOut) {
        if (msg.value > 0) {
            // If you send FTM instead of WETH these requirements must hold.
            require(_fromToken == WETH, "invalid-from-token");
            require(_amountIn == msg.value, "invalid-amount-in");
            // Auto-wrap FTM to WETH
            IWETH(WETH).deposit{value: msg.value}();
        } else {
            IERC20(_fromToken).safeTransferFrom(
                msg.sender,
                address(this),
                _amountIn
            );
        }

        address _router = _getRouter(_toLpToken);

        IERC20(_fromToken).safeApprove(_router, 0);
        IERC20(_fromToken).safeApprove(_router, _amountIn);

        address _token0 = IUniswapV2Pair(_toLpToken).token0();
        address _token1 = IUniswapV2Pair(_toLpToken).token1();

        address _defaultRouter = unirouter;
        unirouter = _router;
        // Uses lpToken' _router as the default router
        // You can override this by using setting a custom path
        // Using setSwapPath

        uint256 _token0Out = _swap(_fromToken, _token0, _amountIn / 2);
        uint256 _token1Out = _swap(
            _fromToken,
            _token1,
            _amountIn - (_amountIn / 2)
        );

        // Revert back to defaultRouter for swaps
        unirouter = _defaultRouter;

        IERC20(_token0).safeApprove(_router, 0);
        IERC20(_token1).safeApprove(_router, 0);
        IERC20(_token0).safeApprove(_router, _token0Out);
        IERC20(_token1).safeApprove(_router, _token1Out);

        uint256 _lpBalanceBefore = IERC20(_toLpToken).balanceOf(address(this));

        _addLiquidity(_router, _token0, _token1, _token0Out, _token1Out, false);

        _lpAmountOut =
            IERC20(_toLpToken).balanceOf(address(this)) -
            _lpBalanceBefore;
        require(_lpAmountOut >= _minLpAmountOut, "slippage-rekt-you");
    }

    function _addLiquidity(
        address _router,
        address _token0,
        address _token1,
        uint256 _token0Out,
        uint256 _token1Out,
        bool _stable
    ) internal virtual {
        IUniswapV2Router02(_router).addLiquidity(
            _token0,
            _token1,
            _token0Out,
            _token1Out,
            0,
            0,
            address(this),
            block.timestamp
        );
    }

    function _removeLiquidity(
        address _router,
        address _token0,
        address _token1,
        uint256 _amountLpIn,
        bool _stable
    ) internal virtual {
        IUniswapV2Router02(_router).removeLiquidity(
            _token0,
            _token1,
            _amountLpIn,
            0,
            0,
            address(this),
            block.timestamp
        );
    }

    function _unzapFromLp(
        address _fromLpToken,
        address _toToken,
        uint256 _amountLpIn,
        uint256 _minAmountOut
    ) internal virtual returns (uint256 _amountOut) {
        address _router = _getRouter(_fromLpToken);

        address _token0 = IUniswapV2Pair(_fromLpToken).token0();
        address _token1 = IUniswapV2Pair(_fromLpToken).token1();

        IERC20(_fromLpToken).safeApprove(_router, 0);
        IERC20(_fromLpToken).safeApprove(_router, _amountLpIn);

        _removeLiquidity(_router, _token0, _token1, _amountLpIn, false);

        address _defaultRouter = unirouter;
        unirouter = _router;
        // Uses lpToken' _router as the default router
        // You can override this by using setting a custom path
        // Using setSwapPath

        _swap(_token0, _toToken, IERC20(_token0).balanceOf(address(this)));
        _swap(_token1, _toToken, IERC20(_token1).balanceOf(address(this)));

        // Revert back to defaultRouter for swaps
        unirouter = _defaultRouter;

        _amountOut = IERC20(_toToken).balanceOf(address(this));

        require(_amountOut >= _minAmountOut, "slippage-rekt-you");

        if (_toToken == WETH) {
            IWETH(WETH).withdraw(_amountOut);

            (bool _success, ) = msg.sender.call{value: _amountOut}("");
            require(_success, "eth-transfer-failed");
        } else {
            IERC20(_toToken).transfer(msg.sender, _amountOut);
        }
    }

    function _checkPath(address[] memory _path) internal override {}

    function _checkRouter(address _router) internal override {}
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "./MatrixStrategyBase.sol";
import "./MatrixSwapHelper.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "../interfaces/IUniswapV2Pair.sol";
import "../interfaces/IMasterChef.sol";
import "../interfaces/xBOOI.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

/// @title Base Lp+MasterChef AutoCompound Strategy Framework,
/// all LP strategies will inherit this contract
contract MatrixSingleAutoCompound is MatrixStrategyBase, MatrixSwapHelper {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    uint256 public poolId;
    address public masterchef;
    address public output;
    address public USDC = 0x04068DA6C83AFCFA0e13ba15A6696662335D5B75;
    address internal constant MAGICATS = 0x2aB5C606a5AA2352f8072B9e2E8A213033e2c4c9;
    address internal constant SPOOKYSWAP_ROUTER = 0xF491e7B69E4244ad4002BC14e878a34207E38c29;
    address internal constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant SD = 0x412a13C109aC30f0dB80AD3Bd1DeFd5D0A6c0Ac6;
    address internal constant SFTMX = 0xd7028092c830b5C8FcE061Af2E593413EbbC1fc1;
    address internal constant BOO = 0x841FAD6EAe12c286d1Fd18d1d525DFfA75C7EFFE;
    address internal constant XBOO = 0xa48d959AE2E88f1dAA7D5F611E01908106dE7598;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixStrategyBase(_want, _vault, _treasury)
        MatrixSwapHelper(_uniRouter)
    {
        _initialize(_masterchef, _output, _poolId);
    }

    function _initialize(
        address _masterchef,
        address _output,
        uint256 _poolId
    ) internal virtual {
        masterchef = _masterchef;
        output = _output;
        poolId = _poolId;

        _setWhitelistedAddresses();
        _setDefaultSwapPaths();
        _giveAllowances();
    }

    /// @notice Allows strategy governor to setup custom path and dexes for token swaps
    function setSwapPath(
        address _fromToken,
        address _toToken,
        address _unirouter,
        address[] memory _path
    ) external onlyOwner {
        _setSwapPath(_fromToken, _toToken, _unirouter, _path);
    }

    /// @notice Override this to enable other routers or token swap paths
    function _setWhitelistedAddresses() internal virtual {
        whitelistedAddresses.add(unirouter);
        whitelistedAddresses.add(USDC);
        whitelistedAddresses.add(want);
        whitelistedAddresses.add(output);
        whitelistedAddresses.add(wrapped);
        whitelistedAddresses.add(SD);
        whitelistedAddresses.add(BOO);
        whitelistedAddresses.add(SPOOKYSWAP_ROUTER);
        whitelistedAddresses.add(XBOO);
    }

    function _enterXBOO() internal returns (uint256) {
        uint256 _booBalance = IERC20(BOO).balanceOf(address(this));
        xBOOI(XBOO).enter(_booBalance);
        uint256 xbooBalance = IERC20(XBOO).balanceOf(address(this));
        return xbooBalance;
    }
    
    function _exitXBOO() internal returns (uint256) {
        uint256 _xbooBalance = IERC20(XBOO).balanceOf(address(this));
        xBOOI(XBOO).leave(_xbooBalance);
        uint256 _booBalance = IERC20(BOO).balanceOf(address(this));
        return _booBalance;
    }

    function moveMagicatsFromPoolToPool(uint256 _fromPoolId, uint256 _toPoolId) internal {
        uint256[] memory magicatsIds = getStakedMagicats(_fromPoolId);

        if(magicatsIds.length > 0) {
            // unstake from pool
            IMasterChef(masterchef).stakeAndUnstakeMagicats(_fromPoolId, new uint256[](0), magicatsIds);

            // stake to other pool
            IMasterChef(masterchef).stakeAndUnstakeMagicats(_toPoolId, magicatsIds, new uint256[](0));
        }
    }

    function stakeMagicats(uint256[] memory _tokenIds, uint256 _poolId) external onlyOwner {
        uint256[] memory unstake = new uint256[](0);
        IMasterChef(masterchef).stakeAndUnstakeMagicats(_poolId, _tokenIds, unstake);
    }

    function unstakeMagicats(uint256[] memory _tokenIds, uint256 _poolId) external onlyOwner {
        uint256[] memory stake = new uint256[](0);
        IMasterChef(masterchef).stakeAndUnstakeMagicats(_poolId, stake, _tokenIds);
    }

    function transferMagicat(uint256 _tokenId) external onlyOwner {
        IERC721(MAGICATS).transferFrom(address(this), msg.sender, _tokenId);
    }

    function getStakedMagicats(uint256 _poolId) public view returns (uint256[] memory) {
        return IMasterChef(masterchef).getStakedMagicats(_poolId, address(this));
    }

    function changePid(uint256 _pid) external onlyOwner {
        uint256 _oldPoolId = poolId;

        // check if is a valid pid
        uint256 poolLength = IMasterChef(masterchef).poolLength();
        require(_pid < poolLength, "invalid-pool-id");
        poolId = _pid;

        // get the new output
        (address _output,,,,,,,,,,,) = IMasterChef(masterchef).poolInfo(poolId);
        require(_output != address(0), "invalid-pool-output");
        output = _output;

        // whitelist in the matrixswaphelper
        whitelistedAddresses.add(output);

        // give allowances
        IERC20(output).safeApprove(unirouter, 0);
        IERC20(output).safeApprove(unirouter, type(uint256).max);

        // move magicats
        moveMagicatsFromPoolToPool(_oldPoolId, poolId);
    }

    function _setDefaultSwapPaths() internal virtual {
         // BOO -> SD
        address[] memory _booSd = new address[](4);
        _booSd[0] = BOO;
        _booSd[1] = WFTM;
        _booSd[2] = USDC;
        _booSd[3] = SD;
        _setSwapPath(BOO, SD, SPOOKYSWAP_ROUTER, _booSd);

        // SD -> BOO
        address[] memory _sdBOO = new address[](4);
        _sdBOO[0] = SD;
        _sdBOO[1] = USDC;
        _sdBOO[2] = WFTM;
        _sdBOO[3] = BOO;
        _setSwapPath(SD, BOO, SPOOKYSWAP_ROUTER, _sdBOO);

        if (output != wrapped) {
            address[] memory _path = new address[](2);
            _path[0] = output;
            _path[1] = wrapped;
            _setSwapPath(output, wrapped, address(0), _path);
        }
    }

    function _giveAllowances() internal override {
        // approving tokens
        IERC20(want).safeApprove(masterchef, 0);
        IERC20(want).safeApprove(masterchef, type(uint256).max);

        IERC20(XBOO).safeApprove(masterchef, 0);
        IERC20(XBOO).safeApprove(masterchef, type(uint256).max);

    IERC20(output).safeApprove(unirouter, 0);
        IERC20(output).safeApprove(unirouter, type(uint256).max);

        IERC20(BOO).safeApprove(XBOO, 0);
        IERC20(BOO).safeApprove(XBOO, type(uint256).max);

        // approving NFTs
        IERC721(MAGICATS).setApprovalForAll(masterchef, true);
    }

    function _removeAllowances() internal override {
        // removing approval for tokens
        IERC20(want).safeApprove(masterchef, 0);
        IERC20(output).safeApprove(unirouter, 0);
        IERC20(BOO).safeApprove(XBOO, 0);

        // removing approval for NFTs
        IERC721(MAGICATS).setApprovalForAll(masterchef, false);
    }

    /// @dev total value managed by strategy is want + want staked in MasterChef
    function totalValue() public view virtual override returns (uint256) {
        (uint256 _totalStaked, ) = IMasterChef(masterchef).userInfo(
            poolId,
            address(this)
        );

        uint256 wantStaked = xBOOI(XBOO).xBOOForBOO(_totalStaked);
        return IERC20(want).balanceOf(address(this)) + wantStaked;
    }

    function _deposit() internal virtual override {
        _enterXBOO();
        uint256 _xbooBalance = IERC20(XBOO).balanceOf(address(this));
        IMasterChef(masterchef).deposit(poolId, _xbooBalance);
    }

    function _beforeWithdraw(uint256 _amout) internal virtual override {
        uint256 _xbooAmount = xBOOI(XBOO).BOOForxBOO(_amout);
        IMasterChef(masterchef).withdraw(poolId, _xbooAmount);
        _exitXBOO();
    }

    function _beforeHarvest() internal virtual {
        IMasterChef(masterchef).deposit(poolId, 0);
    }

    function _harvest()
        internal
        virtual
        override
        returns (uint256 _wantHarvested, uint256 _wrappedFeesAccrued)
    {
        _beforeHarvest();
        uint256 _outputBalance = IERC20(output).balanceOf(address(this));
        if (_outputBalance > 0) {
            if (output != wrapped) {
                _wrappedFeesAccrued = _swap(
                    output,
                    wrapped,
                    (_outputBalance * totalFee) / PERCENT_DIVISOR
                );
                _outputBalance = IERC20(output).balanceOf(address(this));
            } else {
                _wrappedFeesAccrued =
                    (_outputBalance * totalFee) /
                    PERCENT_DIVISOR;
                _outputBalance -= _wrappedFeesAccrued;
            }
            
            // now swapping output to want
            _wantHarvested = _swap(
                    output,
                    want,
                    _outputBalance
            );
        }
    }

    function _beforePanic() internal virtual override {
        IMasterChef(masterchef).emergencyWithdraw(poolId);
        _exitXBOO();
    }

    /// @dev _beforeRetireStrat behaves exactly like _beforePanic hook
    function _beforeRetireStrat() internal override {
        _beforePanic();
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface xBOOI is IERC20 {
    function enter(uint256 _amount) external;
    function leave(uint256 _amount) external;
    function xBOOForBOO(uint256 _xBOOAmount) external view returns (uint256);
    function BOOForxBOO(uint256 _booAmount) external view returns (uint256);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)

pragma solidity ^0.8.0;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixStrategyBase.sol";
import "../MatrixSwapHelper.sol";
import "../../interfaces/beets/IBeetsVault.sol";
import "../../interfaces/IMasterChef.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";

/// @title Beets Lp+MasterChef AutoCompound Strategy Framework,
contract BeetsMatrixLpAutoCompound is MatrixStrategyBase, MatrixSwapHelper {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    uint256 public immutable poolId;
    bytes32 public immutable vaultPoolId;
    address public immutable masterchef;

    address public output;
    address public output2;

    address[] public tokens;

    address public constant USDC = 0x04068DA6C83AFCFA0e13ba15A6696662335D5B75;
    address internal constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant DEUS = 0xDE5ed76E7c05eC5e4572CfC88d1ACEA165109E44;
    address internal constant DEI = 0xDE1E704dae0B4051e80DAbB26ab6ad6c12262DA0;
    address internal constant SPOOKYSWAP_ROUTER =
        0xF491e7B69E4244ad4002BC14e878a34207E38c29;
    address internal constant RING = 0x582423C10c9e83387a96d00A69bA3D11ee47B7b5;

    address internal constant BEETS_VAULT =
        0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce;
    IBeetsVault internal constant beetsVault = IBeetsVault(BEETS_VAULT);

    // token index in LP used to swap rewards
    uint256 internal defaultTokenIndex = 0;

    constructor(
        address _want,
        uint256 _poolId,
        bytes32 _vaultPoolId,
        address _masterchef,
        address _output,
        address _output2,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixStrategyBase(_want, _vault, _treasury)
        MatrixSwapHelper(_uniRouter)
    {
        masterchef = _masterchef;
        poolId = _poolId;
        vaultPoolId = _vaultPoolId;

        (address[] memory _tokens, , ) = beetsVault.getPoolTokens(_vaultPoolId);
        for (uint256 i; i < _tokens.length; i++) tokens.push(_tokens[i]);

        output = _output;
        output2 = _output2;

        _setWhitelistedAddresses();
        _setDefaultSwapPaths();
        _giveAllowances();
    }

    /// @notice Allows strategy governor to setup custom path and dexes for token swaps
    function setSwapPath(
        address _fromToken,
        address _toToken,
        address _unirouter,
        address[] memory _path
    ) external onlyOwner {
        _setSwapPath(_fromToken, _toToken, _unirouter, _path);
    }

    /// @notice Override this to enable other routers or token swap paths
    function _setWhitelistedAddresses() internal virtual {
        whitelistedAddresses.add(unirouter);
        whitelistedAddresses.add(SPOOKYSWAP_ROUTER);
        whitelistedAddresses.add(USDC);
        whitelistedAddresses.add(want);
        whitelistedAddresses.add(DEUS);
        whitelistedAddresses.add(DEI);
        whitelistedAddresses.add(WFTM);
        whitelistedAddresses.add(RING);
        whitelistedAddresses.add(output);
        if (output2 != address(0)) whitelistedAddresses.add(output2);
        whitelistedAddresses.add(wrapped);

        for (uint256 i; i < tokens.length; i++) {
            whitelistedAddresses.add(tokens[i]);
        }
    }

    function _setDefaultSwapPaths() internal virtual {
        for (uint256 i; i < tokens.length; i++) {
            if (tokens[i] == wrapped) {
                address[] memory _path = new address[](2);
                _path[0] = output;
                _path[1] = wrapped;
                _setSwapPath(output, tokens[i], address(0), _path);

                if (output2 != address(0)) {
                    address[] memory _path2 = new address[](2);
                    _path2[0] = output;
                    _path2[1] = wrapped;
                    _setSwapPath(output, tokens[i], address(0), _path2);
                }
            } else {
                if (tokens[i] != output) {
                    address[] memory _path = new address[](3);
                    _path[0] = output;
                    _path[1] = wrapped;
                    _path[2] = tokens[i];
                    _setSwapPath(output, tokens[i], address(0), _path);
                }
                if (tokens[i] != output2) {
                    address[] memory _path = new address[](3);
                    _path[0] = output2;
                    _path[1] = wrapped;
                    _path[2] = tokens[i];
                    _setSwapPath(output2, tokens[i], address(0), _path);
                }
            }
        }

        if (output != wrapped) {
            address[] memory _outputToWrapped = new address[](2);
            _outputToWrapped[0] = output;
            _outputToWrapped[1] = wrapped;
            _setSwapPath(output, wrapped, address(0), _outputToWrapped);
        }
        if (output2 != address(0) && output2 != wrapped) {
            address[] memory _output2ToWrapped = new address[](2);
            _output2ToWrapped[0] = output2;
            _output2ToWrapped[1] = wrapped;
            _setSwapPath(output2, wrapped, address(0), _output2ToWrapped);
        }

        // DEUS -> USDC
        address[] memory _deusUsdc = new address[](3);
        _deusUsdc[0] = DEUS;
        _deusUsdc[1] = WFTM;
        _deusUsdc[2] = USDC;
        _setSwapPath(DEUS, USDC, SPOOKYSWAP_ROUTER, _deusUsdc);

        // WFTM -> DEI
        address[] memory _wftmDei = new address[](3);
        _wftmDei[0] = WFTM;
        _wftmDei[1] = USDC;
        _wftmDei[2] = DEI;
        _setSwapPath(WFTM, DEI, SPOOKYSWAP_ROUTER, _wftmDei);

        // DEI -> WFTM
        address[] memory _deiWftm = new address[](3);
        _deiWftm[0] = DEI;
        _deiWftm[1] = USDC;
        _deiWftm[2] = WFTM;
        _setSwapPath(DEI, WFTM, SPOOKYSWAP_ROUTER, _deiWftm);

        // DEUS -> DEI
        address[] memory _deusDei = new address[](4);
        _deusDei[0] = DEUS;
        _deusDei[1] = WFTM;
        _deusDei[2] = USDC;
        _deusDei[3] = DEI;
        _setSwapPath(DEUS, DEI, SPOOKYSWAP_ROUTER, _deusDei);

        // RING -> USDC
        address[] memory _ringUsdc = new address[](2);
        _ringUsdc[0] = RING;
        _ringUsdc[1] = USDC;
        _setSwapPath(RING, USDC, SPOOKYSWAP_ROUTER, _ringUsdc);

        // RING -> WFTM
        address[] memory _ringWftm = new address[](3);
        _ringWftm[0] = RING;
        _ringWftm[1] = USDC;
        _ringWftm[2] = WFTM;
        _setSwapPath(RING, WFTM, SPOOKYSWAP_ROUTER, _ringWftm);
    }

    function _giveAllowances() internal override {
        IERC20(want).safeApprove(masterchef, type(uint256).max);
        IERC20(output).safeApprove(unirouter, type(uint256).max);

        if (output2 != address(0))
            IERC20(output2).safeApprove(unirouter, type(uint256).max);
    }

    function _removeAllowances() internal override {
        IERC20(want).safeApprove(masterchef, 0);
        IERC20(output).safeApprove(unirouter, 0);
        if (output2 != address(0))
            IERC20(output2).safeApprove(unirouter, type(uint256).max);
    }

    /// @dev total value managed by strategy is want + want staked in MasterChef
    function totalValue() public view override returns (uint256) {
        (uint256 _totalStaked, ) = IMasterChef(masterchef).userInfo(
            poolId,
            address(this)
        );
        return IERC20(want).balanceOf(address(this)) + _totalStaked;
    }

    function _deposit() internal virtual override {
        uint256 _wantBalance = IERC20(want).balanceOf(address(this));
        IMasterChef(masterchef).deposit(poolId, _wantBalance, address(this));
    }

    function _beforeWithdraw(uint256 _amout) internal override {
        IMasterChef(masterchef).withdrawAndHarvest(
            poolId,
            _amout,
            address(this)
        );
    }

    function _harvest()
        internal
        virtual
        override
        returns (uint256 _wantHarvested, uint256 _wrappedFeesAccrued)
    {
        IMasterChef(masterchef).harvest(poolId, address(this));
        uint256 _outputBalance = IERC20(output).balanceOf(address(this));
        if (_outputBalance > 0) {
            _wrappedFeesAccrued = _swap(
                output,
                wrapped,
                (_outputBalance * totalFee) / PERCENT_DIVISOR
            );
        }
        if (output2 != address(0)) {
            uint256 _output2Balance = IERC20(output2).balanceOf(address(this));
            if (_output2Balance > 0) {
                _wrappedFeesAccrued += _swap(
                    output2,
                    wrapped,
                    (_output2Balance * totalFee) / PERCENT_DIVISOR
                );
            }
        }
        _wantHarvested = _addLiquidity();
    }

    function _addLiquidity() internal virtual returns (uint256 _wantHarvested) {
        uint256 _wantBalanceBefore = IERC20(want).balanceOf(address(this));

        uint256 _outputBalance = IERC20(output).balanceOf(address(this));
        if (_outputBalance > 0) {
            _swap(output, tokens[defaultTokenIndex], _outputBalance);
        }
        if (output2 != address(0)) {
            uint256 _output2Balance = IERC20(output2).balanceOf(address(this));
            if (_output2Balance > 0) {
                _swap(output2, tokens[defaultTokenIndex], _output2Balance);
            }
        }

        uint256 _tokenForLpBalance = IERC20(tokens[defaultTokenIndex])
            .balanceOf(address(this));

        if (_tokenForLpBalance > 0) {
            IERC20(tokens[defaultTokenIndex]).safeApprove(BEETS_VAULT, 0);
            IERC20(tokens[defaultTokenIndex]).safeApprove(
                BEETS_VAULT,
                _tokenForLpBalance
            );

            IVault.JoinPoolRequest memory _joinPoolRequest;
            _joinPoolRequest.assets = tokens;
            _joinPoolRequest.maxAmountsIn = new uint256[](tokens.length);
            _joinPoolRequest.maxAmountsIn[
                defaultTokenIndex
            ] = _tokenForLpBalance;
            _joinPoolRequest.userData = abi.encode(
                1,
                _joinPoolRequest.maxAmountsIn,
                1
            );

            beetsVault.joinPool(
                vaultPoolId,
                address(this),
                address(this),
                _joinPoolRequest
            );
        }

        return IERC20(want).balanceOf(address(this)) - _wantBalanceBefore;
    }

    function _beforePanic() internal virtual override {
        IMasterChef(masterchef).emergencyWithdraw(poolId, address(this));
    }

    /// @dev _beforeRetireStrat behaves exactly like _beforePanic hook
    function _beforeRetireStrat() internal override {
        _beforePanic();
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "./MatrixLpAutoCompoundOptimism.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

/// @title Base Lp+MasterChef AutoCompound Strategy Framework,
/// all LP strategies will inherit this contract
contract MatrixLpAutoCompoundMultiOptimism is MatrixLpAutoCompoundOptimism {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    address public output2;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _output2,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompoundOptimism(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {
        wrapped = 0x4200000000000000000000000000000000000006;
        // It can be address(0), for single rewards pools
        output2 = _output2;
        if (output2 != address(0)) {
            whitelistedAddresses.add(output2);
        }
        _setDefaultSwapPaths();
    }

    function _setDefaultSwapPaths() internal virtual override {
        super._setDefaultSwapPaths();

        if (output2 != address(0)) {
            address _oldOutput = output;
            output = output2;

            super._setDefaultSwapPaths();

            output = _oldOutput;
        }
    }

    function _harvest()
        internal
        virtual
        override
        returns (uint256 _wantHarvested, uint256 _wrappedFeesAccrued)
    {
        (_wantHarvested, _wrappedFeesAccrued) = super._harvest();
        if (output2 != address(0)) {
            address _oldOutput = output;
            output = output2;

            (
                uint256 _wantHarvestedFromOutput2,
                uint256 _wrappedFeesAccruedFromOutput2
            ) = super._harvest();

            output = _oldOutput;

            _wantHarvested += _wantHarvestedFromOutput2;

            if (lpToken0 == wrapped || lpToken1 == wrapped) {
                // Anything left here in wrapped after adding liquidity
                // Are fees accrued
                _wrappedFeesAccrued = IERC20(wrapped).balanceOf(address(this));
            } else {
                _wrappedFeesAccrued += _wrappedFeesAccruedFromOutput2;
            }
        }
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "./MatrixLpAutoCompound.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

/// @title Base Lp+MasterChef AutoCompound Strategy Framework,
/// all LP strategies will inherit this contract
contract MatrixLpAutoCompoundOptimism is MatrixLpAutoCompound {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {
        wrapped = 0x4200000000000000000000000000000000000006;
        treasury = 0xEaD9f532C72CF35dAb18A42223eE7A1B19bC5aBF;
        _setDefaultSwapPaths();
    }

    function _beforeWithdraw(uint256 _amount) internal override {
        IMasterChef(masterchef).withdrawAndHarvestShort(
            poolId,
            uint128(_amount)
        );
    }

    function _beforeHarvest() internal override {
        IMasterChef(masterchef).harvestShort(poolId);
    }

    function _deposit() internal virtual override {
        uint256 _wantBalance = IERC20(want).balanceOf(address(this));
        IMasterChef(masterchef).depositShort(poolId, uint128(_wantBalance));
    }

    function _beforePanic() internal virtual override {
        IMasterChef(masterchef).withdrawAll(poolId);
    }

}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixLpAutoCompound.sol";

/// @title MatrixLpAutoCompound adapted to yodeswap for custom routing
contract YodeswapMatrixLpAutoCompound is MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant YODESWAP_ROUTER = 0x72d85Ab47fBfc5E7E04a8bcfCa1601D8f8cE1a50;

    address internal constant WWDOGE = 0xB7ddC6414bf4F5515b52D8BdD69973Ae205ff101;
    address internal constant YODE = 0x6FC4563460d5f45932C473334d5c1C5B4aEA0E01;
    address internal constant USDCM = 0x765277EebeCA2e31912C9946eAe1021199B39C61;
    address internal constant USDTM = 0xE3F5a90F9cb311505cd691a46596599aA1A0AD7D;
    address internal constant DAIM = 0x639A647fbe20b6c8ac19E48E2de44ea792c62c5C;
    address internal constant ETHM = 0xB44a9B6905aF7c801311e8F4E76932ee959c663C;
    address internal constant BTC = 0xfA9343C3897324496A05fC75abeD6bAC29f8A40f;
    address internal constant BUSD = 0x332730a4F6E03D9C55829435f10360E13cfA41Ff;
    address internal constant BNB = 0xA649325Aa7C5093d12D6F98EB4378deAe68CE23F;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {}

    function _initialize(address _masterchef, address _output, uint256 _poolId) internal override {
        wrapped = 0xB7ddC6414bf4F5515b52D8BdD69973Ae205ff101;
        treasury = 0xAA6481333fC2D213d38BE388f255b2647627f12b;
        USDC = address(0x765277EebeCA2e31912C9946eAe1021199B39C61);

        partner = address(0x2a2e3486204C9EEeab2BeF8faa3356Bc19e9db6F);
        treasuryFee = 6800;
        partnerFee = 2200;

        super._initialize(_masterchef, _output, _poolId);
    }

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(YODESWAP_ROUTER);
        whitelistedAddresses.add(WWDOGE);
        whitelistedAddresses.add(USDCM);
        whitelistedAddresses.add(USDTM);
        whitelistedAddresses.add(DAIM);
        whitelistedAddresses.add(ETHM);
        whitelistedAddresses.add(BTC);
        whitelistedAddresses.add(BUSD);
        whitelistedAddresses.add(BNB);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();

        // YODE -> USDC
        address[] memory _yodeUSDCM = new address[](3);
        _yodeUSDCM[0] = YODE;
        _yodeUSDCM[1] = WWDOGE;
        _yodeUSDCM[2] = USDCM;
        _setSwapPath(YODE, USDCM, YODESWAP_ROUTER, _yodeUSDCM);

        // YODE -> USDT
        address[] memory _yodeUSDT = new address[](4);
        _yodeUSDT[0] = YODE;
        _yodeUSDT[1] = WWDOGE;
        _yodeUSDT[2] = USDCM;
        _yodeUSDT[3] = USDTM;
        _setSwapPath(YODE, USDTM, YODESWAP_ROUTER, _yodeUSDT);

        // YODE -> ETH
        address[] memory _yodeETH = new address[](4);
        _yodeETH[0] = YODE;
        _yodeETH[1] = WWDOGE;
        _yodeETH[2] = USDCM;
        _yodeETH[3] = ETHM;
        _setSwapPath(YODE, ETHM, YODESWAP_ROUTER, _yodeETH);

        // YODE -> BTC
        address[] memory _yodeBTC = new address[](4);
        _yodeBTC[0] = YODE;
        _yodeBTC[1] = WWDOGE;
        _yodeBTC[2] = USDCM;
        _yodeBTC[3] = BTC;
        _setSwapPath(YODE, BTC, YODESWAP_ROUTER, _yodeBTC);

        // YODE -> BUSD
        address[] memory _yodeBUSD = new address[](4);
        _yodeBUSD[0] = YODE;
        _yodeBUSD[1] = WWDOGE;
        _yodeBUSD[2] = USDCM;
        _yodeBUSD[3] = BUSD;
        _setSwapPath(YODE, BUSD, YODESWAP_ROUTER, _yodeBUSD);

        // YODE -> BNB
        address[] memory _yodeBNB = new address[](5);
        _yodeBNB[0] = YODE;
        _yodeBNB[1] = WWDOGE;
        _yodeBNB[2] = USDCM;
        _yodeBNB[3] = BUSD;
        _yodeBNB[4] = BNB;
        _setSwapPath(YODE, BNB, YODESWAP_ROUTER, _yodeBNB);
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixLpAutoCompound.sol";

/// @title MatrixLpAutoCompound adapted to SpookyV2 DEUS routing
contract SpookyV2MatrixLpAutoCompound is MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;
    using SafeERC20 for IERC20;

    address internal constant SPOOKYSWAP_ROUTER =
        0xF491e7B69E4244ad4002BC14e878a34207E38c29;

    address public output2;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _output2,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {
        // It can be address(0), for single rewards pools
        output2 = _output2;
        if (output2 != address(0)) {
            whitelistedAddresses.add(output2);
        }
        _setDefaultSwapPaths();
    }

    function _setDefaultSwapPaths() internal virtual override {
        super._setDefaultSwapPaths();

        if (output2 != address(0)) {

            address _oldOutput = output;
            output = output2;

            super._setDefaultSwapPaths();

            output = _oldOutput;
        }
    }

    function _setWhitelistedAddresses() internal virtual override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(SPOOKYSWAP_ROUTER);
    }

    function _harvest()
        internal
        virtual
        override
        returns (uint256 _wantHarvested, uint256 _wrappedFeesAccrued)
    {
        (_wantHarvested, _wrappedFeesAccrued) = super._harvest();
        if (output2 != address(0)) {
            address _oldOutput = output;
            output = output2;

            (
                uint256 _wantHarvestedFromOutput2,
                uint256 _wrappedFeesAccruedFromOutput2
            ) = super._harvest();

            output = _oldOutput;

            _wantHarvested += _wantHarvestedFromOutput2;

            if (lpToken0 == wrapped || lpToken1 == wrapped) {
                // Anything left here in wrapped after adding liquidity
                // Are fees accrued
                _wrappedFeesAccrued = IERC20(wrapped).balanceOf(address(this));
            } else {
                _wrappedFeesAccrued += _wrappedFeesAccruedFromOutput2;
            }
        }
    }

    function _beforePanic() internal override {
        IMasterChef(masterchef).emergencyWithdraw(poolId, address(this));
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "./SpookyV2MatrixLpAutoCompound.sol";

/// @title SpookyV2MatrixLpAutoCompound adapted to SpookyV2 SD routing
contract SdSpookyV2MatrixLpAutoCompound is SpookyV2MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant SD = 0x412a13C109aC30f0dB80AD3Bd1DeFd5D0A6c0Ac6;
    address internal constant SFTMX =
        0xd7028092c830b5C8FcE061Af2E593413EbbC1fc1;
    address internal constant BOO = 0x841FAD6EAe12c286d1Fd18d1d525DFfA75C7EFFE;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _output2,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        SpookyV2MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _output2,
            _uniRouter,
            _vault,
            _treasury
        )
    {}

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(SD);
        whitelistedAddresses.add(SFTMX);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();

        // FTM -> SD
        address[] memory _ftmSd = new address[](3);
        _ftmSd[0] = WFTM;
        _ftmSd[1] = USDC;
        _ftmSd[2] = SD;
        _setSwapPath(WFTM, SD, SPOOKYSWAP_ROUTER, _ftmSd);

        // SD -> USDC
        address[] memory _sdUsdc = new address[](2);
        _sdUsdc[0] = SD;
        _sdUsdc[1] = USDC;
        _setSwapPath(SD, USDC, SPOOKYSWAP_ROUTER, _sdUsdc);

        // USDC -> SD
        address[] memory _usdcSd = new address[](2);
        _usdcSd[0] = USDC;
        _usdcSd[1] = SD;
        _setSwapPath(USDC, SD, SPOOKYSWAP_ROUTER, _usdcSd);

        // SD -> FTM
        address[] memory _sdFtm = new address[](3);
        _sdFtm[0] = SD;
        _sdFtm[1] = USDC;
        _sdFtm[2] = WFTM;
        _setSwapPath(SD, WFTM, SPOOKYSWAP_ROUTER, _sdFtm);

        // SD -> sFTMx
        address[] memory _sdSftmx = new address[](4);
        _sdSftmx[0] = SD;
        _sdSftmx[1] = USDC;
        _sdSftmx[2] = WFTM;
        _sdSftmx[3] = SFTMX;
        _setSwapPath(SD, SFTMX, SPOOKYSWAP_ROUTER, _sdSftmx);

        // BOO -> SD
        address[] memory _booSd = new address[](4);
        _booSd[0] = BOO;
        _booSd[1] = WFTM;
        _booSd[2] = USDC;
        _booSd[3] = SD;
        _setSwapPath(BOO, SD, SPOOKYSWAP_ROUTER, _booSd);
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "./SpookyV2MatrixLpAutoCompound.sol";

/// @title SpookyV2MatrixLpAutoCompound adapted to SpookyV2 DEUS routing
contract DeusSpookyV2MatrixLpAutoCompound is SpookyV2MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant DEUS = 0xDE5ed76E7c05eC5e4572CfC88d1ACEA165109E44;
    address internal constant DEI = 0xDE12c7959E1a72bbe8a5f7A1dc8f8EeF9Ab011B3;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        SpookyV2MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            address(0),
            _uniRouter,
            _vault,
            _treasury
        )
    {}

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(SPOOKYSWAP_ROUTER);
        whitelistedAddresses.add(DEUS);
        whitelistedAddresses.add(DEI);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();

        // DEUS -> USDC
        address[] memory _deusUsdc = new address[](3);
        _deusUsdc[0] = DEUS;
        _deusUsdc[1] = WFTM;
        _deusUsdc[2] = USDC;
        _setSwapPath(DEUS, USDC, SPOOKYSWAP_ROUTER, _deusUsdc);

        // DEUS -> DEI
        address[] memory _deusDei = new address[](4);
        _deusDei[0] = DEUS;
        _deusDei[1] = WFTM;
        _deusDei[2] = USDC;
        _deusDei[3] = DEI;
        _setSwapPath(DEUS, DEI, SPOOKYSWAP_ROUTER, _deusDei);
    }

}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixLpAutoCompound.sol";

/// @title MatrixLpAutoCompound adapted to spiritswap ring routing
contract SpookyRingMatrixLpAutoCompound is MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant SPOOKYSWAP_ROUTER =
        0xF491e7B69E4244ad4002BC14e878a34207E38c29;

    address internal constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant BOO = 0x841FAD6EAe12c286d1Fd18d1d525DFfA75C7EFFE;
    address internal constant RING = 0x582423C10c9e83387a96d00A69bA3D11ee47B7b5;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {
        partner = 0x370880694995Aa8A53F71645F7Bec3b0e7bb25d9;
        partnerFee = 4500;
        treasuryFee = 4500;
    }

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(SPOOKYSWAP_ROUTER);
        whitelistedAddresses.add(RING);
        whitelistedAddresses.add(BOO);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();

        // BOO -> RING
        address[] memory _booRing = new address[](4);
        _booRing[0] = BOO;
        _booRing[1] = WFTM;
        _booRing[2] = USDC;
        _booRing[3] = RING;
        _setSwapPath(BOO, RING, SPOOKYSWAP_ROUTER, _booRing);

        // BOO -> USDC
        address[] memory _booUsdc = new address[](3);
        _booUsdc[0] = BOO;
        _booUsdc[1] = WFTM;
        _booUsdc[2] = USDC;
        _setSwapPath(BOO, USDC, SPOOKYSWAP_ROUTER, _booUsdc);

    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixLpAutoCompound.sol";

/// @title MatrixLpAutoCompound adapted to spiritswap ring routing
contract SpiritRingMatrixLpAutoCompound is MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant SPIRITSWAP_ROUTER = 0x16327E3FbDaCA3bcF7E38F5Af2599D2DDc33aE52;

    address internal constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant SPIRIT = 0x5Cc61A78F164885776AA610fb0FE1257df78E59B;
    address internal constant RING = 0x582423C10c9e83387a96d00A69bA3D11ee47B7b5;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {
        partner = 0x370880694995Aa8A53F71645F7Bec3b0e7bb25d9;
        partnerFee = 4500;
        treasuryFee = 4500;
    }

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(SPIRITSWAP_ROUTER);
        whitelistedAddresses.add(RING);
        whitelistedAddresses.add(SPIRIT);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "./MatrixLpAutoCompound.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

/// @title Base Lp+MasterChef AutoCompound Strategy Framework,
/// all LP strategies will inherit this contract
contract MatrixLpAutoCompoundDogechain is MatrixLpAutoCompound {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {
        wrapped = 0xB7ddC6414bf4F5515b52D8BdD69973Ae205ff101;
        treasury = 0xAA6481333fC2D213d38BE388f255b2647627f12b;
        _setDefaultSwapPaths();
    }

    function _beforeWithdraw(uint256 _amount) internal override {
        IMasterChef(masterchef).withdrawAndHarvestShort(
            poolId,
            uint128(_amount)
        );
    }

    function _beforeHarvest() internal override {
        IMasterChef(masterchef).harvestShort(poolId);
    }

    function _deposit() internal virtual override {
        uint256 _wantBalance = IERC20(want).balanceOf(address(this));
        IMasterChef(masterchef).depositShort(poolId, uint128(_wantBalance));
    }

    function _beforePanic() internal virtual override {
        IMasterChef(masterchef).withdrawAll(poolId);
    }

}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixLpAutoCompound.sol";

/// @title MatrixLpAutoCompound adapted to kibbleswap for custom routing
contract KibbleswapMatrixLpAutoCompound is MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant KIBBLESWAP_ROUTER = 0x6258c967337D3faF0C2ba3ADAe5656bA95419d5f;

    address internal constant WWDOGE = 0xB7ddC6414bf4F5515b52D8BdD69973Ae205ff101;
    address internal constant KIB = 0x1e1026ba0810e6391b0F86AFa8A9305c12713B66;
    address internal constant USDTS = 0x7f8e71DD5A7e445725F0EF94c7F01806299e877A;
    address internal constant USDTM = 0xE3F5a90F9cb311505cd691a46596599aA1A0AD7D;
    address internal constant USDCS = 0x85C2D3bEBffD83025910985389aB8aD655aBC946;
    address internal constant USDCM = 0x765277EebeCA2e31912C9946eAe1021199B39C61;
    address internal constant DAIS = 0xB3306f03595490e5cC3a1b1704a5a158D3436ffC;
    address internal constant DAIM = 0x639A647fbe20b6c8ac19E48E2de44ea792c62c5C;
    address internal constant ETHS = 0x9F4614E4Ea4A0D7c4B1F946057eC030beE416cbB;
    address internal constant ETHM = 0xB44a9B6905aF7c801311e8F4E76932ee959c663C;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {}

    function _initialize(address _masterchef, address _output, uint256 _poolId) internal override {
        wrapped = 0xB7ddC6414bf4F5515b52D8BdD69973Ae205ff101;
        treasury = 0xAA6481333fC2D213d38BE388f255b2647627f12b;
        USDC = address(0x765277EebeCA2e31912C9946eAe1021199B39C61);

        partner = address(0x1E3d78C7cA0cb7D3EdF8682708a0c741d8AB12f0);
        treasuryFee = 6250;
        partnerFee = 2750;

        super._initialize(_masterchef, _output, _poolId);
    }

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(KIBBLESWAP_ROUTER);
        whitelistedAddresses.add(WWDOGE);
        whitelistedAddresses.add(USDTS);
        whitelistedAddresses.add(USDTM);
        whitelistedAddresses.add(DAIS);
        whitelistedAddresses.add(DAIM);
        whitelistedAddresses.add(ETHS);
        whitelistedAddresses.add(ETHM);
        whitelistedAddresses.add(USDCS);
        whitelistedAddresses.add(USDCM);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();

        // KIB -> USDCS
        address[] memory _kibUSDCS = new address[](3);
        _kibUSDCS[0] = KIB;
        _kibUSDCS[1] = USDCM;
        _kibUSDCS[2] = USDCS;
        _setSwapPath(KIB, USDCS, KIBBLESWAP_ROUTER, _kibUSDCS);

        // KIB -> USDTS
        address[] memory _kibUSDTS = new address[](4);
        _kibUSDTS[0] = KIB;
        _kibUSDTS[1] = WWDOGE;
        _kibUSDTS[2] = USDTM;
        _kibUSDTS[3] = USDTS;
        _setSwapPath(KIB, USDTS, KIBBLESWAP_ROUTER, _kibUSDTS);

        // KIB -> ETHS
        address[] memory _kibETHS = new address[](4);
        _kibETHS[0] = KIB;
        _kibETHS[1] = WWDOGE;
        _kibETHS[2] = ETHM;
        _kibETHS[3] = ETHS;
        _setSwapPath(KIB, ETHS, KIBBLESWAP_ROUTER, _kibETHS);

        // KIB -> DAIS
        address[] memory _kibDAIS = new address[](4);
        _kibDAIS[0] = KIB;
        _kibDAIS[1] = WWDOGE;
        _kibDAIS[2] = DAIM;
        _kibDAIS[3] = DAIS;
        _setSwapPath(KIB, DAIS, KIBBLESWAP_ROUTER, _kibDAIS);
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixLpAutoCompound.sol";

/// @title MatrixLpAutoCompound adapted to Hamster routing
contract HamsterMatrixLpAutoCompound is MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant SPOOKYSWAP_ROUTER =
        0xF491e7B69E4244ad4002BC14e878a34207E38c29;

    address internal constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant HAM = 0x20AC818b34A60117E12ffF5bE6AbbEF68BF32F6d;
    address internal constant HSHARE = 0xFFEAF32AB5F99F95a9B6dF177ef56D84fb40fc12;
    address internal constant GEM = 0x42e270Af1FeA762fCFCB65CDB9e3eFFEb2301533;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {}

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(SPOOKYSWAP_ROUTER);
        whitelistedAddresses.add(HAM);
        whitelistedAddresses.add(HSHARE);
        whitelistedAddresses.add(GEM);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();

    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixLpAutoCompound.sol";

/// @title MatrixLpAutoCompound adapted to dante routing
contract DanteMatrixLpAutoCompound is MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant SPOOKYSWAP_ROUTER = 0xF491e7B69E4244ad4002BC14e878a34207E38c29;

    address internal constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant TOMB = 0x6c021Ae822BEa943b2E66552bDe1D2696a53fbB7;
    address internal constant GRAIL = 0x255861B569D44Df3E113b6cA090a1122046E6F89;
    address internal constant DANTE = 0xDA763530614fb51DFf9673232C8B3b3e0A67bcf2;


    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {
        partner = 0x698d286d660B298511E49dA24799d16C74b5640D;
        partnerFee = 1000;
        treasuryFee = 8000;
    }

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(SPOOKYSWAP_ROUTER);
        whitelistedAddresses.add(GRAIL);
        whitelistedAddresses.add(TOMB);
        whitelistedAddresses.add(DANTE);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();

        // GRAIL -> DANTE
        address[] memory _grailDante = new address[](4);
        _grailDante[0] = GRAIL;
        _grailDante[1] = WFTM;
        _grailDante[2] = TOMB;
        _grailDante[3] = DANTE;
        _setSwapPath(GRAIL, DANTE, SPOOKYSWAP_ROUTER, _grailDante);

        // GRAIL -> TOMB
        address[] memory _grailTomb = new address[](3);
        _grailTomb[0] = GRAIL;
        _grailTomb[1] = WFTM;
        _grailTomb[2] = TOMB;
        _setSwapPath(GRAIL, TOMB, SPOOKYSWAP_ROUTER, _grailTomb);
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixLpAutoCompound.sol";

/// @title MatrixLpAutoCompound adapted to ChargeDEFI routing
contract ChargeDefiMatrixLpAutoCompound is MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant SPOOKYSWAP_ROUTER =
        0xF491e7B69E4244ad4002BC14e878a34207E38c29;

    address internal constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant STATIC = 0x27182C8b647fd83603bB442C0E450DE7445ccfB8;
    address internal constant CHARGE = 0xe74621A75C6ADa86148b62Eef0894E05444EAE69;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {}

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(SPOOKYSWAP_ROUTER);
        whitelistedAddresses.add(STATIC);
        whitelistedAddresses.add(CHARGE);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();

        // Charge -> Static
        address[] memory _chargeStatic = new address[](3);
        _chargeStatic[0] = CHARGE;
        _chargeStatic[1] = USDC;
        _chargeStatic[2] = STATIC;
        _setSwapPath(CHARGE, STATIC, SPOOKYSWAP_ROUTER, _chargeStatic);

        // Charge -> USDC
        address[] memory _chargeUsdc = new address[](2);
        _chargeUsdc[0] = CHARGE;
        _chargeUsdc[1] = USDC;
        _setSwapPath(CHARGE, USDC, SPOOKYSWAP_ROUTER, _chargeUsdc);

        // Charge -> WFTM
        address[] memory _chargeWftm = new address[](3);
        _chargeWftm[0] = CHARGE;
        _chargeWftm[1] = USDC;
        _chargeWftm[2] = WFTM;
        _setSwapPath(CHARGE, WFTM, SPOOKYSWAP_ROUTER, _chargeWftm);
    }

    function _deposit() internal override {
        uint256 _wantBalance = IERC20(want).balanceOf(address(this));
        IMasterChef(masterchef).deposit(_wantBalance, poolId);
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixLpAutoCompound.sol";

/// @title MatrixLpAutoCompound adapted to claim BSHARE rewards from the correct routes
contract TombMatrixLpAutoCompound is MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant TOMBSWAP_ROUTER = 0x6D0176C5ea1e44b08D3dd001b0784cE42F47a3A7;
    address internal constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant TOMB = 0x6c021Ae822BEa943b2E66552bDe1D2696a53fbB7;
    address internal constant MAI = 0xfB98B335551a418cD0737375a2ea0ded62Ea213b;
    address internal constant TSHARE = 0x4cdF39285D7Ca8eB3f090fDA0C069ba5F4145B37;
    address internal constant BTC = 0x321162Cd933E2Be498Cd2267a90534A804051b11;
    address internal constant ETH = 0x74b23882a30290451A17c44f4F05243b6b58C76d;
    address internal constant MIM = 0x82f0B8B456c1A451378467398982d4834b6829c1;
    address internal constant FUSDT = 0x049d68029688eAbF473097a2fC38ef61633A3C7A;
    address internal constant FUSD = 0xAd84341756Bf337f5a0164515b1f6F993D194E1f;
    address internal constant TREEB = 0xc60D7067dfBc6f2caf30523a064f416A5Af52963;
    address internal constant ZOO = 0x09e145A1D53c0045F41aEEf25D8ff982ae74dD56;
    address internal constant SCREAM = 0xe0654C8e6fd4D733349ac7E09f6f23DA256bF475;
    address internal constant LIFE = 0xbf60e7414EF09026733c1E7de72E7393888C64DA;
    address internal constant LSHARE = 0xCbE0CA46399Af916784cADF5bCC3aED2052D6C45;
    address internal constant BNB = 0xD67de0e0a0Fd7b15dC8348Bb9BE742F3c5850454;
    address internal constant AVAX = 0x511D35c52a3C244E7b8bd92c0C297755FbD89212;
    address internal constant LINK = 0xb3654dc3D10Ea7645f8319668E8F54d2574FBdC8;
    address internal constant CRV = 0x1E4F97b9f9F913c46F1632781732927B9019C68b;
    address internal constant DAI = 0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {}

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(LIFE);
        whitelistedAddresses.add(LSHARE);
        whitelistedAddresses.add(TOMBSWAP_ROUTER);
        whitelistedAddresses.add(TOMB);
        whitelistedAddresses.add(BTC);
        whitelistedAddresses.add(MAI);
        whitelistedAddresses.add(TSHARE);
        whitelistedAddresses.add(ETH);
        whitelistedAddresses.add(MIM);
        whitelistedAddresses.add(FUSDT);
        whitelistedAddresses.add(FUSD);
        whitelistedAddresses.add(TREEB);
        whitelistedAddresses.add(SCREAM);
        whitelistedAddresses.add(ZOO);
        whitelistedAddresses.add(BNB);
        whitelistedAddresses.add(AVAX);
        whitelistedAddresses.add(LINK);
        whitelistedAddresses.add(CRV);
        whitelistedAddresses.add(DAI);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();

        // LSHARE -> FTM
        address[] memory _lshareFtm = new address[](3);
        _lshareFtm[0] = LSHARE;
        _lshareFtm[1] = USDC;
        _lshareFtm[2] = WFTM;
        _setSwapPath(LSHARE, WFTM, TOMBSWAP_ROUTER, _lshareFtm);

        // LSHARE -> TOMB
        address[] memory _lshareTomb = new address[](3);
        _lshareTomb[0] = LSHARE;
        _lshareTomb[1] = USDC;
        _lshareTomb[2] = TOMB;
        _setSwapPath(LSHARE, TOMB, TOMBSWAP_ROUTER, _lshareTomb);

        // LSHARE -> USDC
        address[] memory _lshareUsdc = new address[](2);
        _lshareUsdc[0] = LSHARE;
        _lshareUsdc[1] = USDC;
        _setSwapPath(LSHARE, USDC, TOMBSWAP_ROUTER, _lshareUsdc);

        // LSHARE -> ZOO
        address[] memory _lshareZoo = new address[](4);
        _lshareZoo[0] = LSHARE;
        _lshareZoo[1] = USDC;
        _lshareZoo[2] = TOMB;
        _lshareZoo[3] = ZOO;
        _setSwapPath(LSHARE, ZOO, TOMBSWAP_ROUTER, _lshareZoo);

        // LSHARE -> TREEB
        address[] memory _lshareTreeb = new address[](4);
        _lshareTreeb[0] = LSHARE;
        _lshareTreeb[1] = USDC;
        _lshareTreeb[2] = TOMB;
        _lshareTreeb[3] = TREEB;
        _setSwapPath(LSHARE, TREEB, TOMBSWAP_ROUTER, _lshareTreeb);

        // LSHARE -> BTC
        address[] memory _lshareBtc = new address[](4);
        _lshareBtc[0] = LSHARE;
        _lshareBtc[1] = USDC;
        _lshareBtc[2] = WFTM;
        _lshareBtc[3] = BTC;
        _setSwapPath(LSHARE, BTC, TOMBSWAP_ROUTER, _lshareBtc);

        // LSHARE -> ETH
        address[] memory _lshareEth = new address[](4);
        _lshareEth[0] = LSHARE;
        _lshareEth[1] = USDC;
        _lshareEth[2] = WFTM;
        _lshareEth[3] = ETH;
        _setSwapPath(LSHARE, ETH, TOMBSWAP_ROUTER, _lshareEth);

        // LSHARE -> TSHARE
        address[] memory _lshareTshare = new address[](2);
        _lshareTshare[0] = LSHARE;
        _lshareTshare[1] = TSHARE;
        _setSwapPath(LSHARE, TSHARE, TOMBSWAP_ROUTER, _lshareTshare);

        // LSHARE -> FUSDT
        address[] memory _lshareFusdt = new address[](3);
        _lshareFusdt[0] = LSHARE;
        _lshareFusdt[1] = USDC;
        _lshareFusdt[2] = FUSDT;
        _setSwapPath(LSHARE, FUSDT, TOMBSWAP_ROUTER, _lshareFusdt);

        // LSHARE -> MIM
        address[] memory _lshareMim = new address[](3);
        _lshareMim[0] = LSHARE;
        _lshareMim[1] = USDC;
        _lshareMim[2] = MIM;
        _setSwapPath(LSHARE, MIM, TOMBSWAP_ROUTER, _lshareMim);

        // LSHARE -> FUSD
        address[] memory _lshareFusd = new address[](3);
        _lshareFusd[0] = LSHARE;
        _lshareFusd[1] = USDC;
        _lshareFusd[2] = FUSD;
        _setSwapPath(LSHARE, FUSD, TOMBSWAP_ROUTER, _lshareFusd);

        // LSHARE -> DAI
        address[] memory _lshareDai = new address[](4);
        _lshareDai[0] = LSHARE;
        _lshareDai[1] = USDC;
        _lshareDai[2] = WFTM;
        _lshareDai[3] = DAI;
        _setSwapPath(LSHARE, DAI, TOMBSWAP_ROUTER, _lshareDai);

        // LSHARE -> BNB
        address[] memory _lshareBnb = new address[](4);
        _lshareBnb[0] = LSHARE;
        _lshareBnb[1] = USDC;
        _lshareBnb[2] = WFTM;
        _lshareBnb[3] = BNB;
        _setSwapPath(LSHARE, BNB, TOMBSWAP_ROUTER, _lshareBnb);

        // LSHARE -> AVAX
        address[] memory _lshareAvax = new address[](4);
        _lshareAvax[0] = LSHARE;
        _lshareAvax[1] = USDC;
        _lshareAvax[2] = WFTM;
        _lshareAvax[3] = AVAX;
        _setSwapPath(LSHARE, AVAX, TOMBSWAP_ROUTER, _lshareAvax);

        // LSHARE -> LINK
        address[] memory _lshareLink = new address[](4);
        _lshareLink[0] = LSHARE;
        _lshareLink[1] = USDC;
        _lshareLink[2] = WFTM;
        _lshareLink[3] = LINK;
        _setSwapPath(LSHARE, LINK, TOMBSWAP_ROUTER, _lshareLink);

        // LSHARE -> CRV
        address[] memory _lshareCrv = new address[](4);
        _lshareCrv[0] = LSHARE;
        _lshareCrv[1] = USDC;
        _lshareCrv[2] = WFTM;
        _lshareCrv[3] = CRV;
        _setSwapPath(LSHARE, CRV, TOMBSWAP_ROUTER, _lshareCrv);

        // LSHARE -> LIFE
        address[] memory _lshareLife = new address[](3);
        _lshareLife[0] = LSHARE;
        _lshareLife[1] = USDC;
        _lshareLife[2] = LIFE;
        _setSwapPath(LSHARE, LIFE, TOMBSWAP_ROUTER, _lshareLife);
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../MatrixLpAutoCompound.sol";

/// @title MatrixLpAutoCompound adapted to claim BSHARE rewards from the correct routes
contract BasedMatrixLpAutoCompound is MatrixLpAutoCompound {
    using EnumerableSet for EnumerableSet.AddressSet;

    address internal constant SPOOKYSWAP_ROUTER =
        0xF491e7B69E4244ad4002BC14e878a34207E38c29;

    address internal constant WFTM = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;
    address internal constant TOMB = 0x6c021Ae822BEa943b2E66552bDe1D2696a53fbB7;
    address internal constant TSHARE = 0x4cdF39285D7Ca8eB3f090fDA0C069ba5F4145B37;
    address internal constant BSHARE = 0x49C290Ff692149A4E16611c694fdED42C954ab7a;
    address internal constant BASED = 0x8D7d3409881b51466B483B11Ea1B8A03cdEd89ae;
    address internal constant MAI = 0xfB98B335551a418cD0737375a2ea0ded62Ea213b;

    constructor(
        address _want,
        uint256 _poolId,
        address _masterchef,
        address _output,
        address _uniRouter,
        address _vault,
        address _treasury
    )
        MatrixLpAutoCompound(
            _want,
            _poolId,
            _masterchef,
            _output,
            _uniRouter,
            _vault,
            _treasury
        )
    {}

    function _setWhitelistedAddresses() internal override {
        super._setWhitelistedAddresses();
        whitelistedAddresses.add(SPOOKYSWAP_ROUTER);
        whitelistedAddresses.add(TOMB);
        whitelistedAddresses.add(TSHARE);
        whitelistedAddresses.add(BSHARE);
        whitelistedAddresses.add(BASED);
        whitelistedAddresses.add(MAI);
    }

    function _setDefaultSwapPaths() internal override {
        super._setDefaultSwapPaths();

        // BSHARE -> BASED
        address[] memory _bshareBased = new address[](2);
        _bshareBased[0] = BSHARE;
        _bshareBased[1] = BASED;
        _setSwapPath(BSHARE, BASED, SPOOKYSWAP_ROUTER, _bshareBased);

       // BSHARE -> TOMB
        address[] memory _bshareTomb = new address[](3);
        _bshareTomb[0] = BSHARE;
        _bshareTomb[1] = BASED;
        _bshareTomb[2] = TOMB;
        _setSwapPath(BSHARE, TOMB, SPOOKYSWAP_ROUTER, _bshareTomb);

        // BSHARE -> FTM
        address[] memory _bshareWFTM = new address[](2);
        _bshareWFTM[0] = BSHARE;
        _bshareWFTM[1] = WFTM;
        _setSwapPath(BSHARE, WFTM, SPOOKYSWAP_ROUTER, _bshareWFTM);

        // BSHARE -> MAI
        address[] memory _bshareMAI = new address[](4);
        _bshareMAI[0] = BSHARE;
        _bshareMAI[1] = WFTM;
        _bshareMAI[2] = USDC;
        _bshareMAI[3] = MAI;
        _setSwapPath(BSHARE, MAI, SPOOKYSWAP_ROUTER, _bshareMAI);
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MatrixTreasuryDogechain is Ownable {
    using SafeERC20 for IERC20;

    address public accountant;

    struct Withdrawal {
      uint amount;
      address token;
      uint time;
      bool reviewed;
    }

    uint counter = 0;

    mapping(uint => Withdrawal) public withdrawals;

    function viewWithdrawal(uint index) public view returns (uint, address, uint, bool) {
      Withdrawal memory receipt = withdrawals[index];
      return(receipt.amount, receipt.token, receipt.time, receipt.reviewed);
    }

    function markReviewed(uint index) public returns (bool) {
      require(msg.sender == accountant, "not authorized");
      withdrawals[index].reviewed = true;
      return true;
    }

    function withdrawTokens(address _token, address _to, uint256 _amount) external onlyOwner {
      withdrawals[counter] = Withdrawal(_amount, _token, block.timestamp, false);
      counter++;
      IERC20(_token).safeTransfer(_to, _amount);
    }

    function withdrawNative(address payable _to, uint256 _amount) external onlyOwner {
      withdrawals[counter] = Withdrawal(_amount, address(0), block.timestamp, false);
      counter++;
      _to.transfer(_amount);
    }

    function setAccountant(address _addr) public onlyOwner returns (bool) {
      accountant = _addr;
      return true;
    }

    receive () external payable {}
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)

pragma solidity ^0.8.0;

import "./IERC20.sol";
import "./extensions/IERC20Metadata.sol";
import "../../utils/Context.sol";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
     * `transferFrom`. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum `uint256`.
     *
     * Requirements:
     *
     * - `from` and `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     * - the caller must have allowance for ``from``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, _allowances[owner][spender] + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = _allowances[owner][spender];
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `sender` to `recipient`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     */
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[from] = fromBalance - amount;
        }
        _balances[to] += amount;

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Spend `amount` form the allowance of `owner` toward `spender`.
     *
     * Does not update the allowance amount in case of infinite allowance.
     * Revert if not enough allowance is available.
     *
     * Might emit an {Approval} event.
     */
    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./interfaces/IMatrixStrategy.sol";

/**
 * @dev Implementation of a vault to deposit funds for yield optimizing.
 * This is the contract that receives funds and that users interface with.
 * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.
 */
contract MatrixVault is ERC20, Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    struct StratCandidate {
        address implementation;
        uint256 proposedTime;
    }

    event Deposit(address indexed _user, uint256 _wantAmount);
    event Withdraw(address indexed _user, uint256 _wantAmount);
    
    /**
     * @dev The stretegy's initialization status. Gives deployer 20 minutes after contract
     * construction (constructionTime) to set the strategy implementation.
     */
    bool public initialized = false;
    uint256 public constructionTime;

    // The last proposed strategy to switch to.
    StratCandidate public stratCandidate;
    // The strategy currently in use by the vault.
    address public strategy;
    // The minimum time it has to pass before a strat candidate can be approved.
    uint256 public immutable approvalDelay;

    event NewStratCandidate(address implementation);
    event UpgradeStrat(address implementation);

    /**
     * @dev Sets the value of {token} to the token that the vault will
     * hold as underlying value. It initializes the vault's own 'moo' token.
     * This token is minted when someone does a deposit. It is burned in order
     * to withdraw the corresponding portion of the underlying assets.
     * @param _name the name of the vault token.
     * @param _symbol the symbol of the vault token.
     * @param _approvalDelay the delay before a new strat can be approved.
     */
    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _approvalDelay
    ) ERC20(_name, _symbol) {
        approvalDelay = _approvalDelay;
        constructionTime = block.timestamp;
    }

    /**
     * @dev Connects the vault to its initial strategy. One use only.
     * @notice deployer has only 20 minutes after construction to connect the initial strategy.
     * @param _strategy the vault's initial strategy
     */

    function initialize(address _strategy) public onlyOwner returns (bool) {
        require(!initialized, "Contract is already initialized.");
        require(
            block.timestamp <= (constructionTime + 1200),
            "initialization period over, use timelock"
        );
        strategy = _strategy;
        initialized = true;
        return true;
    }

    function want() public view returns (IERC20) {
        return IERC20(IMatrixStrategy(strategy).want());
    }

    /**
     * @dev It calculates the total underlying value of {token} held by the system.
     * It takes into account the vault contract balance, the strategy contract balance
     *  and the balance deployed in other contracts as part of the strategy.
     */
    function balance() public view returns (uint256) {
        return
            want().balanceOf(address(this)) +
            IMatrixStrategy(strategy).balanceOf();
    }

    /**
     * @dev Custom logic in here for how much the vault allows to be borrowed.
     * We return 100% of tokens for now. Under certain conditions we might
     * want to keep some of the system funds at hand in the vault, instead
     * of putting them to work.
     */
    function available() public view returns (uint256) {
        return want().balanceOf(address(this));
    }

    /**
     * @dev Function for various UIs to display the current value of one of our yield tokens.
     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.
     */
    function getPricePerFullShare() public view returns (uint256) {
        return totalSupply() == 0 ? 1e18 : (balance() * 1e18) / totalSupply();
    }

    /**
     * @dev A helper function to call deposit() with all the sender's funds.
     */
    function depositAll() external {
        deposit(want().balanceOf(msg.sender));
    }

    /**
     * @dev The entrypoint of funds into the system. People deposit with this function
     * into the vault. The vault is then in charge of sending funds into the strategy.
     */
    function deposit(uint256 _amount) virtual public nonReentrant {
        _deposit(_amount);
    }

    function _deposit(uint256 _amount) internal virtual  {

        require(_amount > 0, "please provide amount");

        emit Deposit(msg.sender, _amount);

        IMatrixStrategy(strategy).beforeDeposit();

        uint256 _pool = balance();
        want().safeTransferFrom(msg.sender, address(this), _amount);
        earn();
        uint256 _after = balance();
        _amount = _after - _pool; // Additional check for deflationary tokens
        uint256 shares = 0;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount * totalSupply()) / _pool;
        }
        _mint(msg.sender, shares);

    }

    /**
     * @dev Function to send funds into the strategy and put them to work. It's primarily called
     * by the vault's deposit() function.
     */
    function earn() public {
        uint256 _bal = available();
        want().safeTransfer(strategy, _bal);
        IMatrixStrategy(strategy).deposit();
    }

    /**
     * @dev A helper function to call withdraw() with all the sender's funds.
     */
    function withdrawAll() external {
        withdraw(balanceOf(msg.sender));
    }

    /**
     * @dev Function to exit the system. The vault will withdraw the required tokens
     * from the strategy and pay up the token holder. A proportional number of IOU
     * tokens are burned in the process.
     */
    function withdraw(uint256 _shares) virtual public nonReentrant {
        _withdraw(_shares);
    }

    function _withdraw(uint256 _shares) internal virtual {

        require(_shares > 0, "please provide amount");

        uint256 r = (balance() * _shares) / totalSupply();

        emit Withdraw(msg.sender, r);

        _burn(msg.sender, _shares);

        uint256 b = want().balanceOf(address(this));
        if (b < r) {
            uint256 _withdraw = r - b;
            IMatrixStrategy(strategy).withdraw(_withdraw);
            uint256 _after = want().balanceOf(address(this));
            uint256 _diff = _after - b;
            if (_diff < _withdraw) {
                r = b + _diff;
            }
        }

        want().safeTransfer(msg.sender, r);
    }

    /**
     * @dev Sets the candidate for the new strat to use with this vault.
     * @param _implementation The address of the candidate strategy.
     */
    function proposeStrat(address _implementation) public onlyOwner {
        require(
            address(this) == IMatrixStrategy(_implementation).vault(),
            "Proposal not valid for this Vault"
        );
        stratCandidate = StratCandidate({
            implementation: _implementation,
            proposedTime: block.timestamp
        });

        emit NewStratCandidate(_implementation);
    }

    /**
     * @dev It switches the active strat for the strat candidate. After upgrading, the
     * candidate implementation is set to the 0x00 address, and proposedTime to a time
     * happening in +100 years for safety.
     */

    function upgradeStrat() public onlyOwner {
        require(
            stratCandidate.implementation != address(0),
            "There is no candidate"
        );
        require(
            stratCandidate.proposedTime + approvalDelay < block.timestamp,
            "Delay has not passed"
        );

        emit UpgradeStrat(stratCandidate.implementation);

        IMatrixStrategy(strategy).retireStrat();
        strategy = stratCandidate.implementation;
        stratCandidate.implementation = address(0);
        stratCandidate.proposedTime = 5000000000;

        earn();
    }

    /**
     * @dev Rescues random funds stuck that the strat can't handle.
     * @param _token address of the token to rescue.
     */
    function inCaseTokensGetStuck(address _token) external onlyOwner {
        require(_token != address(want()), "!token");

        uint256 amount = IERC20(_token).balanceOf(address(this));
        IERC20(_token).safeTransfer(msg.sender, amount);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "../../MatrixVault.sol";

contract RadiantMatrixVault is MatrixVault {
    uint256 public lockPeriod = 7 days;
    mapping(address => uint256) public depositTime;
    event LockPeriodUpdated(uint256 _oldLockPeriod, uint256 _lockPeriod);

    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _approvalDelay
    ) MatrixVault(_name, _symbol, _approvalDelay) {}

    modifier isNotLocked(address _user) {
        require(
            block.timestamp >= depositTime[_user] + lockPeriod,
            "withdraw-time-has-not-passed"
        );
        _;
    }

    function deposit(uint256 _amount) public override nonReentrant {
        depositTime[msg.sender] = block.timestamp;
        _deposit(_amount);
    }

    function withdraw(uint256 _amount)
        public
        override
        isNotLocked(msg.sender)
        nonReentrant
    {
        _withdraw(_amount);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override isNotLocked(from) {}

    function updateLockPeriod(uint256 _lockPeriod) external onlyOwner {
        require(
            _lockPeriod > 1 days,
            "lock-period-must-be-gt-1-day"
        );
        require(
            _lockPeriod <= 30 days,
            "lock-period-must-be-lt-1-month"
        );
        emit LockPeriodUpdated(lockPeriod, _lockPeriod);
        lockPeriod = _lockPeriod;
    }
}

// SPDX-License-Identifier: MIT
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./MatrixVault.sol";
import "./strategies/MatrixLpAutoCompoundOptimism.sol";

pragma solidity ^0.8.6;

contract MatrixProxy {
    // returning want, pricePerFullShare, balance, balanceOfUser, allowanceOfUser
    function getInfo(address _userAddress, address _vaultAddress, address _strategy, address _zapAddress) public view returns (IERC20, uint256, uint256, uint256, uint256, uint256) {        
        address _user = _userAddress;
        address _zap = _zapAddress;
        address _vault = _vaultAddress;

        MatrixVault vault = MatrixVault(_vault);


        IERC20 want = vault.want();
        uint256 pricePerFullShare = vault.getPricePerFullShare();
        uint256 balance = vault.balance();
        uint256 balanceOfUser = vault.balanceOf(_user);
        uint256 allowanceOfUser = vault.allowance(_user, _zap);
        uint256 lpAllowance = want.allowance(_user, _vault);

        return (want, pricePerFullShare, balance, balanceOfUser, allowanceOfUser, lpAllowance);
    }
}

// SPDX-License-Identifier: MIT
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./MatrixVault.sol";

pragma solidity ^0.8.6;

contract MatrixAggregationProxy {
    function userBalances(address _userAddress, address[] memory _vaults) public view returns (uint256[] memory) {
        uint256[] memory balances = new uint256[](_vaults.length);

        for(uint i = 0; i < _vaults.length; i++) {
            MatrixVault vault = MatrixVault(_vaults[i]);
            uint256 balanceOfUser = vault.balanceOf(_userAddress);
            balances[i] = balanceOfUser;
        }

        return balances;
    }

    function usersBalances(address[] memory _users, address[] memory _vaults) public view returns (uint256[][] memory) {
        uint256[][] memory balances = new uint256[][](_users.length);

        for(uint i = 0; i < _users.length; i++) {
            balances[i] = userBalances(_users[i], _vaults);
        }

        return balances;
    }
}